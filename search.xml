<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[INV]]></title>
    <url>%2FEBS%2FINV%2F</url>
    <content type="text"><![CDATA[主组织物料123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130SELECT Msib.Organization_Id 库存组织id ,Mp.Organization_Code 库存组织编码 ,Msib.Inventory_Item_Id 物料id ,Msib.Segment1 物料编码 ,Msib.Description 物料描述 ,Msib.Lot_Control_Code 批次过期控制 ,Mc.Segment1 大类 ,Mc.Segment2 中类 ,Mc.Segment3 小类 ,Mc.Description 类别描述 ,Msib.Attribute19 申请事业部编码 ,Mist.Inventory_Item_Status_Code_Tl 物料状态 ,Flv.Meaning 用户物料类型 ,Msib.Primary_Unit_Of_Measure 单位 ,Decode(Msib.Planning_Make_Buy_Code, 1, '制造', 2, '采购', '') 制造或采购 ,Msib.Fixed_Lot_Multiplier 固定批次增加 ,Msib.Mtl_Transactions_Enabled_Flag 可处理库存 ,Msib.Bom_Enabled_Flag 允许bom ,Gcck_Cs.Concatenated_Segments 销货成本账户 ,Msib.Purchasing_Enabled_Flag 可采购 ,Msib.Build_In_Wip_Flag 在wip中制造 ,Msib.Customer_Order_Enabled_Flag 启用客户订单 ,Msib.Internal_Order_Enabled_Flag 启用内部订单 ,Msib.Invoice_Enabled_Flag 启用开票 ,Gcck_Sa.Concatenated_Segments 销售账户 ,Msib.Attribute2 是否保税物料 ,Msib.Attribute5 是否海鲜物料 ,Msib.Attribute11 配置码 ,Msib.Attribute14 是否ckd物料 ,Msib.Attribute21 安规状态 ,Msib.Attribute22 是否带pc ,Msib.Attribute20 是否通用料 ,Msib.Attribute6 品质控制状态 ,Msib.Attribute7 环保风险等级 ,Msib.Attribute8 海关申报属性 ,Msib.Attribute9 英文物料描述 ,Msib.Attribute12 品名 ,Msib.Attribute16 规格 ,Msib.Attribute17 临时编码 ,Msib.Attribute18 旧编码 ,Msib.Attribute24 图纸号 ,Msib.Attribute25 来源类型 ,Msib.Attribute26 安规基线 ,Msib.Attribute27 Bom备料选项 ,Msib.Attribute15 "Invoice UOM" ,Msib.Preprocessing_Lead_Time 提前期预加工 ,Msib.Full_Lead_Time 提前期加工中 ,Xci.Customs_Code 海关编码 ,Xci.Product_Name 商品名称 ,v.Usage_Rate_Or_Amount * 100 关税 ,Xci.Vat_Rate 增值税 ,Xci.First_Legal_Unit 第一法定单位 ,Xci.Second_Legal_Unit 第二法定单位 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Name = 'XXSRM_ITEM_MACHINE_CATEGORY' AND Ffvs.Flex_Value_Set_Id = Ffv.Flex_Value_Set_Id AND Ffv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffv.Flex_Value = Msib.Attribute29) 整机类别 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Name = 'CVTE_COA_BU' AND Ffvs.Flex_Value_Set_Id = Ffv.Flex_Value_Set_Id AND Ffv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffv.Flex_Value = Msib.Attribute19) 事业部 ,(SELECT Ppf.Full_Name FROM Apps.Per_All_People_f Ppf WHERE Ppf.Person_Id = Msib.Buyer_Id AND SYSDATE BETWEEN Ppf.Effective_Start_Date AND Ppf.Effective_End_Date) 采购组 ,(SELECT Mcbk.Concatenated_Segments FROM Apps.Mtl_Item_Categories Mic ,Apps.Mtl_Categories_b_Kfv Mcbk WHERE Mic.Category_Set_Id = 1100000075 AND Mic.Inventory_Item_Id = Msib.Inventory_Item_Id AND Mic.Organization_Id = Msib.Organization_Id AND Mic.Category_Id = Mcbk.Category_Id) 销售型号 ,(SELECT Mcbk.Concatenated_Segments FROM Apps.Mtl_Item_Categories Mic ,Apps.Mtl_Categories_b_Kfv Mcbk WHERE Mic.Category_Set_Id = 1100000043 AND Mic.Inventory_Item_Id = Msib.Inventory_Item_Id AND Mic.Organization_Id = Msib.Organization_Id AND Mic.Category_Id = Mcbk.Category_Id) Cvte产品型号 ,(SELECT Mcbk.Concatenated_Segments FROM Apps.Mtl_Item_Categories Mic ,Apps.Mtl_Categories_b_Kfv Mcbk WHERE Mic.Category_Set_Id = 1100000076 AND Mic.Inventory_Item_Id = Msib.Inventory_Item_Id AND Mic.Organization_Id = Msib.Organization_Id AND Mic.Category_Id = Mcbk.Category_Id) 采购品类 ,Msib.Lot_Divisible_Flag 可分批次入库 FROM Apps.Mtl_System_Items_b Msib JOIN Apps.Mtl_Parameters Mp ON Msib.Organization_Id = Mp.Organization_Id JOIN Apps.Mtl_Item_Categories Mic ON Mic.Inventory_Item_Id = Msib.Inventory_Item_Id AND Mic.Organization_Id = Msib.Organization_Id AND Mic.Category_Set_Id = 1 JOIN Apps.Mtl_Categories_Vl Mc ON Mc.Category_Id = Mic.Category_Id JOIN Apps.Mtl_Item_Status_Tl Mist ON Msib.Inventory_Item_Status_Code = Mist.Inventory_Item_Status_Code AND Mist.Language = 'ZHS' JOIN Apps.Fnd_Lookup_Values Flv ON Msib.Item_Type = Flv.Lookup_Code AND Flv.Lookup_Type = 'ITEM_TYPE' AND Flv.Language = 'ZHS' JOIN Apps.Gl_Code_Combinations_Kfv Gcck_Cs ON Msib.Cost_Of_Sales_Account = Gcck_Cs.Code_Combination_Id JOIN Apps.Gl_Code_Combinations_Kfv Gcck_Sa ON Msib.Sales_Account = Gcck_Sa.Code_Combination_Id LEFT JOIN (SELECT v.Inventory_Item_Id ,v.Usage_Rate_Or_Amount ,v.Organization_Id FROM Apps.v_Xxsrm0109_Mat_Gatrate v GROUP BY v.Inventory_Item_Id ,v.Usage_Rate_Or_Amount ,v.Organization_Id) v ON Msib.Inventory_Item_Id = v.Inventory_Item_Id AND Msib.Organization_Id = v.Organization_Id LEFT JOIN Xxapex.Xxsrm_Customs_Code_Item Xci ON Msib.Inventory_Item_Id = Xci.Item_Id WHERE 1 = 1 AND Msib.Inventory_Item_Id = 4 --&amp; 物料类别集123456789101112131415161718192021SELECT Mcsv.Category_Set_Id 类别集id ,Mcsv.Category_Set_Name 类别集名称 ,Mcsv.Description 类别集描述 ,Mcv.Category_Id 类别id ,Mcv.Structure_Id 弹性域结构id ,Mcv.Structure_Name 弹性域结构 ,Mcv.Segment1 大类 ,Mcv.Segment2 中类 ,Mcv.Segment3 小类 ,Mcv.Category_Concat_Segs 类别编码 ,Mcv.Description 类别描述 FROM Apps.Mtl_Category_Sets_v Mcsv LEFT JOIN Apps.Mtl_Categories_v Mcv ON Mcv.Structure_Id = Mcsv.Structure_Id WHERE 1 = 1 AND Mcsv.Category_Set_Id = 1 --&amp; AND EXISTS (SELECT 1 FROM Apps.Mtl_Item_Categories Mic WHERE Mic.Category_Set_Id = Mcsv.Category_Set_Id AND Mic.Organization_Id = 86 --&amp; AND Mic.Category_Id = Mcv.Category_Id); 物料类别集是通过了键弹性域（Item Categories）来实现自身数据动态配置，所以才有上图中的弹性域结构这一项 事务处理类型123456789101112SELECT Mtst.Transaction_Source_Type_Id 事务处理来源类型id ,Mtst.Transaction_Source_Type_Name 事务处理来源类型 ,Mtst.User_Defined_Flag 是否用户类型 ,Mtst.Disable_Date 失效日期 -- ,Mtt.Transaction_Type_Id 事务处理类型id ,Mtt.Transaction_Type_Name 事务处理类型 ,Mtt.User_Defined_Flag 是否用户类型 ,Mtt.Disable_Date 失效日期 FROM Apps.Mtl_Txn_Source_Types Mtst ,Apps.Mtl_Transaction_Types Mtt WHERE Mtt.Transaction_Source_Type_Id = Mtst.Transaction_Source_Type_Id(+); 子库123456789101112131415161718192021222324252627282930SELECT Msi.Organization_Id 库存组织id ,Mp.Organization_Code 库存组织 ,Msi.Secondary_Inventory_Name 子库 ,Msi.Description 说明 ,Mms.Status_Code 状态 ,Msi.Disable_Date 失效日期 ,Msi.Attribute1 工厂id ,Psn.Project_Number 工厂代码 ,Psn.Project_Name 工厂 ,Msi.Attribute2 是否保税仓 ,Msi.Attribute3 是否在途仓 ,Msi.Attribute4 是否skd ,Msi.Attribute5 参与供应链报表计算 ,Msi.Attribute6 是否良品存货 ,Msi.Attribute7 子库所属的客户id ,(SELECT Party.Party_Name FROM Apps.Hz_Cust_Accounts Cust ,Apps.Hz_Parties Party WHERE Cust.Party_Id = Party.Party_Id AND To_Char(Cust.Cust_Account_Id) = Msi.Attribute7) 子库所属的客户 ,Msi.Attribute8 发货仓 FROM Apps.Mtl_Secondary_Inventories Msi LEFT JOIN Apps.Mtl_Parameters Mp ON Mp.Organization_Id = Msi.Organization_Id LEFT JOIN Apps.Pjm_Seiban_Numbers Psn ON Psn.Project_Id = Msi.Attribute1 LEFT JOIN Apps.Mtl_Material_Statuses_Tl Mms ON Mms.Language = 'ZHS' AND Mms.Status_Id = Msi.Status_Id WHERE 1=1 货位1234567891011121314151617181920212223242526272829SELECT Mil.Organization_Id 库存组织id ,Mp.Organization_Code 库存组织 ,Mil.Inventory_Location_Id 货位id ,Mil.Segment1 || '.' || Psn.Project_Number || '.' || Mil.Segment2 货位 ,Mil.Description 说明 ,Mms.Status_Code 状态 ,Mil.Disable_Date 失效日期 ,Mil.Segment1 子库 ,Msi.Description 子库说明 ,Mil.Segment19 工厂id ,Psn.Project_Number 工厂编码 ,Mil.Segment2 客户账户 ,(SELECT Hp.Party_Name FROM Apps.Hz_Cust_Accounts Hca ,Apps.Hz_Parties Hp WHERE Hca.Account_Number = Mil.Segment2 AND Hca.Party_Id = Hp.Party_Id) 客户名称 FROM Apps.Mtl_Item_Locations Mil LEFT JOIN Apps.Mtl_Parameters Mp ON Mp.Organization_Id = Mil.Organization_Id LEFT JOIN Apps.Mtl_Secondary_Inventories Msi ON Msi.Secondary_Inventory_Name = Mil.Subinventory_Code AND Msi.Organization_Id = Mil.Organization_Id LEFT JOIN Apps.Pjm_Seiban_Numbers Psn ON Psn.Project_Id = Mil.Segment19 LEFT JOIN Apps.Mtl_Material_Statuses_Tl Mms ON Mms.Language = 'ZHS' AND Mms.Status_Id = Mil.Status_Id WHERE 1 = 1; 组织组织表中包含业务实体和库存组织，通过组织分类区分不同类型 123456HR_ALL_ORGANIZATION_UNITS --组织表HR_ORGANIZATION_INFORMATION --组织分类表MTL_PARAMETERS --组织参数表SELECT * FROM Apps.Hr_Operating_Units Hou;--OU视图SELECT * FROM Apps.Org_Organization_Definitions Ood;--库存组织视图 单位123456789SELECT t.Unit_Of_Measure_Tl 名称 ,t.Uom_Code 单位 ,t.Description 说明 ,t.Base_Uom_Flag 基本单位 ,t.Uom_Class 分类 ,t.Disable_Date 无效日期 FROM Inv.Mtl_Units_Of_Measure_Tl t WHERE t.Language = 'ZHS' AND t.Uom_Code = 'PCS' --&amp;]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[GL]]></title>
    <url>%2FEBS%2FGL%2F</url>
    <content type="text"><![CDATA[会计科目表 (COA)“会计科目”是企业进行财务数据核算工作的基础，“公司段”即为“平衡段”，表示在”公司段”层面日记账 （会计分录）的借项和贷项总是相等的；体现国家法律法规要求的”会计科目”成为其中必不可少的一个组成段即为“自然账户段”（会计科目段），自然账户所使用的值集即为通常所说的”科目表”；“部门段”即为”成本中心段”，成本中LOV值可能是企业中的个具体行政组织，也可能表示共享个成本中心的多个行政组织的组 ，还可能是表示基于统计管理需要而设定的多个成本中心的组合，EBS系统允许会计科目弹性域结构设置最多30个段，但必须至少包含“平衡段”和“自然账户段”。 1234567891011121314151617181920212223242526272829SELECT Fif.Id_Flex_Code 代码 ,Fif.Id_Flex_Name 标题 ,Fif.Application_Table_Name 表名 ,Fif.Concatenated_Segs_View_Name Kfv视图名称 ,Fifsv.Id_Flex_Structure_Code 结构代码 ,Fifs.Segment_Name 名称 ,Fifs.Application_Column_Name 列名 -- ,Ffvs.Flex_Value_Set_Name 值集名称 ,Ffvv.Flex_Value 值集 ,Ffvv.Enabled_Flag 是否启用 ,Ffvv.Start_Date_Active ,Ffvv.End_Date_Active ,Ffvv.Summary_Flag 是否汇总段 ,Ffvv.Parent_Flex_Value_Low 父层值 FROM Apps.Fnd_Id_Flexs Fif LEFT JOIN Apps.Fnd_Id_Flex_Structures_Vl Fifsv ON Fifsv.Application_Id = Fif.Application_Id AND Fifsv.Id_Flex_Code = Fif.Id_Flex_Code LEFT JOIN Apps.Fnd_Id_Flex_Segments Fifs ON Fifs.Application_Id = Fifsv.Application_Id AND Fifs.Id_Flex_Code = Fifsv.Id_Flex_Code AND Fifs.Id_Flex_Num = Fifsv.Id_Flex_Num LEFT JOIN Apps.Fnd_Flex_Value_Sets Ffvs ON Ffvs.Flex_Value_Set_Id = Fifs.Flex_Value_Set_Id LEFT JOIN Apps.Fnd_Flex_Values Ffvv ON Ffvv.Flex_Value_Set_Id = Ffvs.Flex_Value_Set_Id WHERE 1 = 1 AND Fif.Id_Flex_Name = 'Accounting Flexfield' 汇率123456789101112131415161718SELECT Xdr.From_Currency 币种从 ,Xdr.To_Currency 币种到 ,To_Char(Xdr.Conversion_Date, 'yyyy-mm-dd') 汇率日期 ,Xdr.Conversion_Type 汇率类型 ,Gdct.Description 汇率类型说明 ,Xdr.Conversion_Rate 汇率 ,Fct_From.Name 转换币种名称 ,Fct_To.Name 目标币种名称 FROM Apps.Gl_Daily_Rates Xdr JOIN Apps.Gl_Daily_Conversion_Types Gdct ON Gdct.Conversion_Type = Xdr.Conversion_Type LEFT JOIN Apps.Fnd_Currencies_Tl Fct_From ON Fct_From.Language = 'ZHS' AND Fct_From.Currency_Code = Xdr.From_Currency LEFT JOIN Apps.Fnd_Currencies_Tl Fct_To ON Fct_To.Language = 'ZHS' AND Fct_To.Currency_Code = Xdr.To_Currency WHERE 1 = 1]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PO]]></title>
    <url>%2FEBS%2FPO%2F</url>
    <content type="text"><![CDATA[采购申请123456789101112131415161718192021222324252627282930313233343536373839404142434445464748SELECT Prh.Requisition_Header_Id 申请单头id ,Prh.Org_Id 业务实体id ,Prh.Segment1 申请单编号 ,Pdt.Type_Name 类型 ,Flv.Meaning 状态 ,Fu.Description 编制人 ,Gsob.Currency_Code 币种 ,Po_Requisition_Headers_Pkg.Get_Req_Total(Prh.Requisition_Header_Id, Gsob.Currency_Code) 合计 -- ,Prl.Requisition_Line_Id 申请单行id ,Prl.Line_Num 编号 ,Plt.Line_Type 类型 ,Msi.Segment1 物料 ,Prl.Item_Description 说明 ,Prl.Unit_Price 价格 ,Prl.Quantity 数量 FROM Po.Po_Requisition_Headers_All Prh INNER JOIN Po.Po_Document_Types_All_b Pdb ON Pdb.Document_Type_Code = 'REQUISITION' AND Pdb.Document_Subtype = Prh.Type_Lookup_Code AND Pdb.Org_Id = Prh.Org_Id INNER JOIN Po.Po_Document_Types_All_Tl Pdt ON Pdt.Language = 'ZHS' AND Pdt.Document_Type_Code = Pdb.Document_Type_Code AND Pdt.Document_Subtype = Pdb.Document_Subtype AND Pdt.Org_Id = Prh.Org_Id INNER JOIN Apps.Fnd_Lookup_Values Flv ON Flv.Lookup_Type = 'AUTHORIZATION STATUS' AND Flv.Language = 'ZHS' AND Nvl(Flv.Enabled_Flag, 'N') = 'Y' AND SYSDATE BETWEEN Nvl(Flv.Start_Date_Active, SYSDATE) AND Nvl(Flv.End_Date_Active, SYSDATE) AND Flv.Lookup_Code = Nvl(Prh.Authorization_Status, 'INCOMPLETE') INNER JOIN Applsys.Fnd_User Fu ON Fu.Employee_Id = Prh.Preparer_Id INNER JOIN Financials_System_Params_All Fsp ON Fsp.Org_Id = Prh.Org_Id INNER JOIN Apps.Gl_Sets_Of_Books Gsob ON Gsob.Set_Of_Books_Id = Fsp.Set_Of_Books_Id INNER JOIN Po.Po_Requisition_Lines_All Prl ON Prl.Requisition_Header_Id = Prh.Requisition_Header_Id INNER JOIN Apps.Po_Line_Types Plt ON Plt.Line_Type_Id = Prl.Line_Type_Id INNER JOIN Inv.Mtl_System_Items_b Msi ON Msi.Organization_Id = 84 AND Msi.Inventory_Item_Id = Prl.Item_Id WHERE 1 = 1 AND Prh.Segment1 = '10100000010' 合格供应商（ASL）12345678910111213141516171819202122232425262728293031SELECT Asl.Asl_Id 合格供应商id ,Asl.Owning_Organization_Id 库存组织 ,Plc.Displayed_Field 业务 ,Pas.Status 状态 ,Pv.Vendor_Name 供应商 ,Pvsa.Vendor_Site_Code 供应商地点 ,Asl.Item_Id 物料编码 ,Msi.Segment1 物料编码 ,Asl.Category_Id 类别id ,Mc.Category_Concat_Segs 类别编码 ,Asl.Vendor_Site_Id 供应商地点id ,Asl.Disable_Flag 禁用 ,Asl.Comments 备注 FROM Po.Po_Approved_Supplier_List Asl LEFT JOIN Apps.Po_Vendors Pv ON Pv.Vendor_Id = Asl.Vendor_Id LEFT JOIN Apps.Po_Vendor_Sites_All Pvsa ON Pvsa.Vendor_Site_Id = Asl.Vendor_Site_Id LEFT JOIN Po.Po_Asl_Statuses Pas ON Pas.Status_Id = Asl.Asl_Status_Id LEFT JOIN Apps.Po_Lookup_Codes Plc ON Plc.Lookup_Type = 'ASL_VENDOR_BUSINESS_TYPE' AND Plc.Lookup_Code = Asl.Vendor_Business_Type LEFT JOIN Apps.Mtl_System_Items_b Msi ON Msi.Inventory_Item_Id = Asl.Item_Id AND Msi.Organization_Id = Asl.Using_Organization_Id LEFT JOIN Apps.Mtl_Categories_v Mc ON Mc.Category_Id = Asl.Category_Id WHERE 1 = 1 AND Asl.Category_Id = 1426 --&amp; AND Asl.Owning_Organization_Id = 86 --&amp;]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SYS]]></title>
    <url>%2FEBS%2FSYS%2F</url>
    <content type="text"><![CDATA[用户123456789101112131415161718192021222324252627282930313233343536373839SELECT Fu.User_Name 用户名 ,Fu.Description 用户说明 ,Fu.Start_Date 用户启用日期 ,Fu.End_Date 用户终止日期 --,fu.employee_id ,Ppv.Full_Name 员工 --,fud.RESPONSIBILITY_ID ,Frt.Responsibility_Name 职责 --,fud.RESPONSIBILITY_APPLICATION_ID ,Fat.Application_Name 应用名称 --,fud.security_group_id ,Fud.Start_Date 职责启用日期 ,Fud.End_Date 职责终止日期 ,Paf.Effective_Start_Date 分配启用日期 ,Paf.Effective_End_Date 分配终止日期 ,Pou.Name 人员组织 ,Pp.Name 职位 ,Pj.Name 职务 FROM Fnd_User Fu ,Fnd_User_Resp_Groups_Direct Fud ,Fnd_Responsibility_Tl Frt ,Fnd_Application_Tl Fat ,Per_People_V7 Ppv ,Per_Assignments_f Paf ,Per_Positions Pp ,Per_Jobs Pj ,Per_Organization_Units Pou WHERE Fu.User_Id = Fud.User_Id AND Frt.Language = 'ZHS' AND Fud.Responsibility_Id = Frt.Responsibility_Id AND Fat.Language = 'ZHS' AND Fud.Responsibility_Application_Id = Fat.Application_Id AND Fu.Employee_Id = Ppv.Person_Id(+) AND Fud.End_Date IS NULL AND Ppv.Person_Id = Paf.Person_Id(+) AND Paf.Position_Id = Pp.Position_Id(+) AND Paf.Job_Id = Pj.Job_Id(+) AND Paf.Organization_Id = Pou.Organization_Id AND Fu.User_Id = 11314 --&amp; 责任12345678910111213141516SELECT Frv.Application_Id 应用id ,Frv.Responsibility_Id 责任id ,Frv.Responsibility_Key 责任关键字 ,Frv.Responsibility_Name 责任名 ,Frv.Description 说明 ,Frv.Start_Date 有效开始时间 ,Frv.End_Date 有效结束时间 ,Fmv.User_Menu_Name 菜单名称 ,Frg.Request_Group_Name 请求组名称 FROM Apps.Fnd_Responsibility_Vl Frv LEFT JOIN Apps.Fnd_Menus_Vl Fmv ON Fmv.Menu_Id = Frv.Menu_Id LEFT JOIN Apps.Fnd_Request_Groups Frg ON Frg.Request_Group_Id = Frv.Request_Group_Id WHERE 1 = 1 AND Frv.Responsibility_Name = '应用开发员' --&amp; 请求123456789101112131415SELECT Frg.Application_Id 应用id ,Frg.Request_Group_Id 请求组id ,Frg.Request_Group_Name 请求组名称 ,Frg.Description 请求组说明 ,Decode(Rgu.Request_Unit_Type, 'A', '应用', 'P', '程序', 'S', '集合', 'F', '阶段功能') 类型 ,Fcp.User_Concurrent_Program_Name 请求名称 ,Fcp.Description 请求说明 FROM Apps.Fnd_Request_Groups Frg LEFT JOIN Apps.Fnd_Request_Group_Units Rgu ON Rgu.Request_Group_Id = Frg.Request_Group_Id LEFT JOIN Apps.Fnd_Concurrent_Programs_Vl Fcp ON Fcp.Concurrent_Program_Id = Rgu.Request_Unit_Id WHERE 1 = 1 AND Frg.Request_Group_Name = 'Application Developer Reports' --&amp; AND Fcp.User_Concurrent_Program_Name = '生成信息' --&amp; 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950SELECT t.User_Profile_Option_Name Us_Name ,l.User_Profile_Option_Name Zhs_Name ,Decode(v.Level_Id ,10001 ,'地点层' ,10002 ,'应用层' ,10003 ,'职责层' ,10004 ,'用户层' ,10005 ,'服务器层' ,10006 ,'组织层' ,'其它') Level_Name ,Decode(v.Level_Id ,10002 ,(SELECT Application_Name FROM Apps.Fnd_Application_Vl WHERE Application_Id = v.Level_Value) ,10003 ,(SELECT Responsibility_Name FROM Apps.Fnd_Responsibility_Vl WHERE Responsibility_Id = v.Level_Value AND Application_Id = v.Level_Value_Application_Id) ,10004 ,(SELECT User_Name FROM Apps.Fnd_User WHERE User_Id = v.Level_Value) ,10005 ,(SELECT Node_Name FROM Apps.Fnd_Nodes WHERE Node_Id = v.Level_Value) ,10006 ,(SELECT NAME FROM Apps.Hr_Operating_Units WHERE Organization_Id = v.Level_Value) ,v.Level_Value) Level_Value ,v.Profile_Option_Value ,u.User_Name ,v.Last_Update_Date FROM Apps.Fnd_Profile_Options_Vl t ,Apps.Fnd_Profile_Options_Tl l ,Apps.Fnd_Profile_Option_Values v ,Apps.Fnd_User u WHERE t.Application_Id = v.Application_Id AND t.Profile_Option_Id = v.Profile_Option_Id AND t.Profile_Option_Name = l.Profile_Option_Name AND l.Language = 'ZHS' AND u.User_Id = v.Last_Updated_By AND t.Start_Date_Active &lt;= SYSDATE AND Nvl(t.End_Date_Active, SYSDATE) &gt;= SYSDATE AND User_Id NOT IN (-1, 0, 1, 2, 3, 4, 5, 6, 7) AND l.User_Profile_Option_Name = '公用程序：诊断' --&amp; ORDER BY t.User_Profile_Option_Name;]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WIP]]></title>
    <url>%2FEBS%2FWIP%2F</url>
    <content type="text"><![CDATA[工单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768SELECT Wdj.Wip_Entity_Id 工单id ,We.Wip_Entity_Name 工单号 ,Wdj.Organization_Id 库存组织id ,Mp.Organization_Code 库存组织 ,Decode(Wdj.Job_Type, 1, '标准', 3， '非标准') 类型 ,Wdj.Primary_Item_Id 装配件id ,m_Msi.Segment1 装配件 ,Wdj.Class_Code 分类 ,Flv.Meaning 状态 ,Wdj.Start_Quantity 起始数量 ,Wdj.Quantity_Completed 完成数量 ,Wdj.Quantity_Scrapped 报废数量 ,(Wdj.Start_Quantity - Wdj.Quantity_Completed - Wdj.Quantity_Scrapped) 未入库数量 ,Wdj.Scheduled_Start_Date 齐套日期 ,Wdj.Scheduled_Completion_Date 计划完成日期 ,Wdj.Date_Completed 完工日期 ,Wdj.Creation_Date 制单日期 ,Flvv.Meaning 供应方式 ,Wdj.Bom_Revision 版本 ,Psn.Project_Name 工厂 ,Wdj.Lot_Number 生产批次 ,Wov.Operation_Seq_Num 工序 ,Wov.Operation_Code 工序代码 ,Wov.Description 工序说明 ,w_Msi.Segment1 组件 ,Wro.Operation_Seq_Num 组件工序 ,w_Bd.Department_Code 部门 ,Wro.Quantity_Per_Assembly 每个装配件 ,Wro.Component_Yield_Factor 产出率 ,Wro.Required_Quantity 必需数量 ,Wro.Quantity_Issued 已发料数量 FROM Apps.Wip_Discrete_Jobs Wdj JOIN Apps.Wip_Entities We ON We.Wip_Entity_Id = Wdj.Wip_Entity_Id AND We.Organization_Id = Wdj.Organization_Id JOIN Apps.Mtl_Parameters Mp ON Mp.Organization_Id = Wdj.Organization_Id JOIN Apps.Mtl_System_Items_b m_Msi ON m_Msi.Inventory_Item_Id = Wdj.Primary_Item_Id AND m_Msi.Organization_Id = Wdj.Organization_Id LEFT JOIN Apps.Fnd_Lookup_Values Flv --状态值集表 ON Flv.Lookup_Type = 'WIP_JOB_STATUS' AND Flv.Language = 'ZHS' AND Flv.Lookup_Code = Wdj.Status_Type LEFT JOIN Apps.Pjm_Seiban_Numbers Psn ON Psn.Project_Id = Wdj.Project_Id LEFT JOIN Apps.Fnd_Lookup_Values Flvv --供应方式值集表 ON Flvv.Language = 'ZHS' AND Flvv.View_Application_Id = 700 AND Flvv.Security_Group_Id = 0 AND Flvv.Lookup_Type = 'WIP_SUPPLY' AND Flvv.Lookup_Code = Wdj.Wip_Supply_Type LEFT JOIN Apps.Wip_Operations_v Wov --工序表 ON Wov.Wip_Entity_Id = Wdj.Wip_Entity_Id AND Wov.Organization_Id = Wdj.Organization_Id LEFT JOIN Apps.Wip_Requirement_Operations Wro --装配件表 ON Wro.Wip_Entity_Id = Wdj.Wip_Entity_Id AND Wro.Organization_Id = Wdj.Organization_Id AND Wro.Wip_Supply_Type != 6 --虚拟件 AND Wro.Operation_Seq_Num = Wov.Operation_Seq_Num LEFT JOIN Apps.Mtl_System_Items_b w_Msi ON w_Msi.Inventory_Item_Id = Wro.Inventory_Item_Id AND w_Msi.Organization_Id = Wro.Organization_Id LEFT JOIN Apps.Bom_Departments w_Bd --部门表 ON w_Bd.Department_Id = Wro.Department_Id WHERE 1 = 1 AND Wdj.Wip_Entity_Id = 1024 --&amp; AND Wdj.Organization_Id = 86 --&amp;]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WIP]]></title>
    <url>%2FEBS%2FXLE%2F</url>
    <content type="text"><![CDATA[法人主体职责：法人主体管理器路径：法人主体管理器-&gt;设置-&gt;地址-&gt;创建创建“法人地址”，再创建”法人主体”关联上”法人地址”，同步创建”机构”+”机构地址”再关联到”法人主体”上 1234567891011121314151617181920212223242526272829303132SELECT Leetb.Meaning 类型 ,Xep.Legal_Entity_Id 法人id ,Xep.Legal_Entity_Identifier 法人主体标识 --来自COA公司段 ,Xep.Name 法人名称 ,Xep.Effective_From 法人有效开始时间 ,Xep.Effective_To 法人有效结束时间 ,Ftp.Territory_Short_Name 法人国家 ,Hp.Party_Number 组织编码 ,Loc.Address_Line_1 地址行1 ,Loc.Address_Line_2 地址行2 ,Loc.Address_Line_3 地址行3 ,Ft.Territory_Short_Name 地址国家 ,Xlr.Registration_Number 注册编号 ,Xlr.Effective_From 注册有效日期 ,Xlr.Effective_To 注册失效日期 FROM Apps.Xle_Entity_Profiles Xep ,Apps.Xle_Lookups Leetb ,Apps.Hz_Geographies Hg ,Apps.Fnd_Territories_Vl Ftp ,Apps.Hz_Parties Hp ,Apps.Xle_Registrations Xlr ,Apps.Hr_Locations Loc ,Apps.Fnd_Territories_Vl Ft WHERE Leetb.Lookup_Type = 'XLE_LEGAL_TYPE' AND Leetb.Lookup_Code = 'LEGAL_ENTITY' AND Hg.Geography_Id = Xep.Geography_Id AND Hg.Country_Code = Ftp.Territory_Code AND Hp.Party_Id = Xep.Party_Id AND Xlr.Source_Table = 'XLE_ENTITY_PROFILES' AND Xlr.Source_Id = Xep.Legal_Entity_Id AND Xlr.Location_Id = Loc.Location_Id(+) AND Ft.Territory_Code = Loc.Country 机构1234567891011121314151617181920212223242526272829303132333435SELECT Leetb.Meaning 类型 ,Xep.Legal_Entity_Id 父级法人id ,Xle.Name 父级法人名称 ,Xep.Name 机构名称 ,Xep.Effective_From 机构有效开始时间 ,Xep.Effective_To 机构有效结束时间 ,Ftp.Territory_Short_Name 机构国家 ,Hp.Party_Number 组织编码 ,Hl.Address_Line_1 地址行1 ,Hl.Address_Line_2 地址行2 ,Hl.Address_Line_3 地址行3 ,Ft.Territory_Short_Name 地址国家 ,Xlr.Registration_Number 注册编号 --纳税人识别号 ,Xlr.Effective_From 注册有效日期 ,Xlr.Effective_To 注册失效日期 FROM Apps.Xle_Etb_Profiles Xep ,Apps.Hz_Geographies Hg ,Apps.Fnd_Territories_Vl Ftp ,Apps.Hz_Parties Hp ,Apps.Xle_Entity_Profiles Xle ,Apps.Xle_Lookups Leetb ,Apps.Hr_Locations Hl ,Apps.Fnd_Territories_Vl Ft ,Apps.Xle_Registrations Xlr WHERE 1 = 1 AND Hg.Geography_Id = Xep.Geography_Id AND Hg.Country_Code = Ftp.Territory_Code AND Hp.Party_Id = Xep.Party_Id AND Leetb.Lookup_Type = 'XLE_LEGAL_TYPE' AND Leetb.Lookup_Code = 'ESTABLISHMENT' AND Xlr.Source_Table = 'XLE_ETB_PROFILES' AND Xlr.Source_Id = Xep.Establishment_Id AND Xlr.Location_Id = Hl.Location_Id(+) AND Ft.Territory_Code(+) = Hl.Country AND Xle.Legal_Entity_Id = Xep.Legal_Entity_Id 账套&amp;法人&amp;业务实体&amp;库存组织一个法人只能关联给一个账套，辅助分类账不能单独添加法人主体， 必须关联到主要分类帐才与法人主体产生关联业务实体和库存组织其实保存在同一张组织表（Hr_All_Organization_Units），通过组织信息表（Hr_Organization_Information）的字段（Org_Information_Context）来区分类型，弹性域字段（Org_Information3）关联上账套和（Org_Information2）关联上法人 1234567891011121314151617181920212223242526272829303132333435SELECT Gllv.Ledger_Id 账套id ,Gllv.Ledger_Name 账套 ,Gllv.Currency_Code 币种 ,Gllv.Period_Set_Name 会计日历 ,Gllv.Accounted_Period_Type 期间类型 ,(SELECT Xamv.Name FROM Xla_Acctg_Methods_Vl Xamv WHERE Xamv.Accounting_Method_Type_Code = Gllv.Sla_Accounting_Method_Type AND Xamv.Accounting_Method_Code = Gllv.Sla_Accounting_Method_Code) 会计方法 --子分类帐会计方法 ,(SELECT Xl.Meaning FROM Apps.Xla_Lookups Xl WHERE Xl.Lookup_Type = 'XLA_OWNER_TYPE' AND Xl.Lookup_Code = Gllv.Sla_Accounting_Method_Type) 责任人 --子分类帐会计方法责任人 ,Gllv.Chart_Of_Accounts_Id Coa弹性域结构代码id ,Gllv.Bal_Seg_Value_Set_Id Coa弹性域段摘要id ,Gllv.Bal_Seg_Column_Name Coa弹性域段摘要列 ,Gllv.Primary_Ledger_Id 主分类帐id ,Gllv.Relationship_Enabled_Flag 主分类帐是否启用 ,Gllv.Legal_Entity_Id 法人id ,Gllv.Legal_Entity_Name 法人名称 ,(SELECT Hla.Address_Line_1 || Hla.Address_Line_2 || Hla.Address_Line_3 FROM Hr.Hr_Locations_All Hla WHERE Hla.Location_Id = Gllv.Location_Id) 法定地址 ,Hou.Organization_Id 业务实体id ,Hou.Name 业务实体 ,Hou.Short_Code 业务实体code ,Ood.Organization_Id 库存组织 ,Ood.Organization_Code 库存组织code FROM Apps.Gl_Ledger_Le_v Gllv LEFT JOIN Apps.Hr_Operating_Units Hou ON Hou.Set_Of_Books_Id = Gllv.Ledger_Id AND Hou.Default_Legal_Context_Id = Gllv.Legal_Entity_Id LEFT JOIN Apps.Org_Organization_Definitions Ood ON Hou.Organization_Id = Ood.Operating_Unit WHERE 1 = 1 职责：总账超级用户路径：设置&gt;财务系统&gt;会计科目设置管理器&gt;会计科目设置]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZX]]></title>
    <url>%2FEBS%2FZX%2F</url>
    <content type="text"><![CDATA[税率123456789101112SELECT Zrb.Tax_Rate_Code 税码 ,Zrb.Percentage_Rate 税率 ,Zrb.Tax_Status_Code 税名称 ,Zrb.Active_Flag 状态 ,Zrb.Effective_From 有效开始时间 ,Zrb.Effective_To 有效结束时间 ,Hou.Name 业务实体 FROM Apps.Zx_Rates_b Zrb LEFT JOIN Apps.Zx_Accounts Za ON Za.Tax_Account_Entity_Id = Zrb.Tax_Rate_Id LEFT JOIN Apps.Hr_Operating_Units Hou ON Hou.Organization_Id = Za.Internal_Organization_Id 进入税务管理员职责]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[001-基础]]></title>
    <url>%2FOracle%2F001-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建表空间创建临时表空间(TIPS：如果建立的是插接式数据库，表空间名、用户名、角色名必须C##打头) 1234567CREATE TEMPORARY TABLESPACE C##APPSTABLESPACE_TEMPTEMPFILE 'D:\Sortware\app\oracle\tablespace\apps\c##appstablespace_temp.dbf'SIZE 32M --初始大小AUTOEXTEND ON --自动扩展NEXT 32M --每次拓展大小MAXSIZE 5G --最大存储值，MAXSIZE UNLIMITED则指不受限制EXTENT MANAGEMENT LOCAL; --EXTENT MANAGEMENT LOCAL(本地管理);EXTENT MANAGEMENT DICTIONARY(数据字典管理) 创建用户表空间 1234567CREATE TABLESPACE C##APPSTABLESPACELOGGING DATAFILE 'D:\Sortware\app\oracle\tablespace\apps\c##appstablespace.dbf'SIZE 32M AUTOEXTEND ON NEXT 32M MAXSIZE 10G EXTENT MANAGEMENT LOCAL; 删除表空间（包括物理数据文件） 1DROP TABLESPACE C##APPSTABLESPACE INCLUDING CONTENTS AND DATAFILES; 创建用户创建用户并指定表空间 123CREATE USER C##APPS IDENTIFIED BY "apps"DEFAULT TABLESPACE C##APPSTABLESPACETEMPORARY TABLESPACE C##APPSTABLESPACE_TEMP; 修改用户密码 1ALTER USER C##APPS IDENTIFIED BY apps; 用户授权(初始创建用户未授权会导致无法登陆) 1234567GRANT CREATE SESSION, CREATE ANY TABLE, CREATE ANY VIEW, CREATE ANY INDEX, CREATE ANY SEQUENCE, CREATE ANY PROCEDURE, ALTER ANY TABLE, ALTER ANY INDEX, ALTER ANY SEQUENCE, ALTER ANY PROCEDURE, DROP ANY TABLE, DROP ANY VIEW, DROP ANY INDEX, DROP ANY SEQUENCE, DROP ANY PROCEDURE, SELECT ANY TABLE, INSERT ANY TABLE, UPDATE ANY TABLE, DELETE ANY TABLE, exp_full_database, --导出数据库的权限 imp_full_database --导入数据库的权限 TO C##APPS; 取消用户授权 1REVOKE CREATE ANY TABLE FROM C##APPS; 查看用户权限 12345678910111213SELECT a.Grantee ,a.Granted_Role ,a.Admin_Option ,a.Common FROM Dba_Role_Privs a WHERE a.Grantee = 'C##APPS'UNION ALLSELECT a.Grantee ,a.Privilege ,a.Admin_Option ,a.Common FROM Dba_Sys_Privs a WHERE a.Grantee = 'C##APPS'; 删除用户 1DROP USER C##APPS CASCADE; --cascade参数是级联删除该用户所有对象 创建角色三种标准的角色：CONNECT、RESOURCE、DBA查看角色权限 1SELECT * FROM Role_Sys_Privs WHERE Role = 'RESOURCE'; 创建角色 1CREATE ROLE C##APPS_ROLE; 授权角色 1GRANT CREATE ANY TABLE C##APPS_ROLE; 角色授予用户 1GRANT C##APPS_ROLE TO C##APPS; 取消角色授予用户 1REVOKE C##APPS_ROLE FROM C##APPS; 删除角色 1DROP ROLE C##APPS_ROLE; DDLTABLE创建表 1234567891011CREATE TABLE Tablename(User_Id NUMBER NOT NULL ,User_Name VARCHAR2(10) DEFAULT 'Zts' ,Creation_Date DATE DEFAULT SYSDATE NOT NULL ,Created_By NUMBER DEFAULT -1 NOT NULL ,Last_Updated_By NUMBER DEFAULT -1 NOT NULL ,Last_Update_Date DATE DEFAULT SYSDATE NOT NULL ,Last_Update_Login NUMBER ,Fictitious AS(User_Id * 10) Virtual --虚拟列 --虚拟列可以用在select，update，delete语句的where条件中，但是不能用于DML语句 --可以基于虚拟列来做分区、建索引、建约束 ); 表/列说明 12COMMENT ON TABLE tablename IS '表名';COMMENT ON COLUMN tablename.user_id IS '列说明'; 复制表(只复制表结构，不复制表数据) 12CREATE TABLE new_tablename AS SELECT * FROM tablename WHERE 1 = 2; 添加、更改、删除列，修改列名，添加虚拟列 12345ALTER TABLE tablename ADD remarks NUMBER;ALTER TABLE tablename MODIFY remarks Varchar2(4000);ALTER TABLE tablename DROP COLUMN remarks;ALTER TABLE tablename RENAME COLUMN remarks TO remark;ALTER TABLE tablename ADD (fictitious AS (user_id * 10)); --虚拟列 删除表 1DROP TABLE tablename; 更改表名 1RENAME tablename TO new_tablename; 临时表PRESERVE：会话断开后数据会自动删除DELETE：COMMIT后会自动删除 1CREATE Global Temporary TABLE Temptable(Id NUMBER) ON COMMIT PRESERVE/DELETE ROWS; VIEW创建视图 12CREATE OR REPLACE VIEW tablename_v AS SELECT * FROM tablename; 删除视图 1DROP VIEW tablename_v; SEQUENCE创建序列 1234567CREATE SEQUENCE tablename_sNOMINVALUE --无最小值NOMAXVALUE --无最大值START WITH 1 --从1开始INCREMENT BY 1 --增量1NOCYCLE --序列不循环 CACHE 20; --指定Cache值 修改序列 123456ALTER SEQUENCE tablename_sMINVALUE 0 --最小值MAXVALUE 40 --最大值 INCREMENT BY 2 --增量NCYCLE --序列循环(设置为循环时必须有最大最小值)NOCACHE; --无Cache值 删除序列 1DROP SEQUENCE tablename_s; INDEX创建索引 123456--唯一性索引CREATE UNIQUE INDEX tablename_u1 ON tablename(user_id);--普通索引CREATE INDEX tablename_n1 ON tablename(user_name);--创建函数索引CREATE INDEX tablename_upper_n1 ON tablename(UPPER(user_name)); TIPS：什么样的情况下不适合创建索引 被查询的表本身就很小，即是是全表扫描也非常快 基于这张表的查询，大多数情况下需要获取的数据量都超过了总量的4% 这张表需要频繁的被更新，建立索引的话会引起索引的频繁更新，从而反而降低数据库的整体效率 SYNONYM创建同义词 1CREATE SYNONYM new_tablename FOR tablename; 删除同义词 1DROP SYNONYM new_tablename; DMLSELECT查询 123456SELECT e.Empno 工号 ,e.Ename "姓名" ,e.Job AS "职位" ,Nvl(e.Deptno, 0) 部门编号 ,(SELECT d.Dname FROM Dept d WHERE d.Deptno = e.Deptno) 部门名称 FROM Emp e; INSERT插入 1INSERT INTO Tablename (User_Id, User_Name) VALUES (Tablename_s.Nextval, 'Zts'); 复制另一个表数据 1INSERT INTO New_Tablename SELECT * FROM Tablename; UPDATE更新 1UPDATE Tablename SET User_Name = 'Zts' WHERE User_Id = 1; DELETE/TRUNCATE删除 12DELETE Tablename WHERE User_Id = 1;TRUNCATE TABLE Tablename; --Truncate只能删除一整个表的数据且无法回滚（谨慎使用） DQLDECODE条件判断 1SELECT Decode(e.Deptno, 10, 'ACCOUNTING', 20, 'RESEARCH', 'SALES') FROM Emp e; CASE条件判断 123456789SELECT (CASE e.Deptno WHEN 10 THEN 'ACCOUNTING' WHEN 20 THEN 'RESEARCH' ELSE 'SALES' END) Dname FROM Emp e; WITHWITH相当于把查询出来的数据存到临时表，后续查询直接从临时表里查询，能适当提高查询效率 12345678WITH Tb1 AS (SELECT e.Empno FROM Emp e WHERE e.Sal &gt; 1500), Tb2 AS (SELECT e.Empno FROM Emp e WHERE e.Deptno &lt;&gt; 10)SELECT * FROM Tb1 ,Tb2 WHERE Tb1.Empno = Tb2.Empno; LIKE模糊匹配‘ _ ‘ 代表单个字符‘ % ‘ 代表0个或多个字符 1SELECT e.* FROM Emp e WHERE e.Ename LIKE '_M%'; ESCAPE使’ % ‘ 和 ‘ _ ‘不作为通配符使用 1SELECT * FROM Emp e WHERE e.Ename LIKE '%\%%' ESCAPE '\'; --使\后面的%不作为通配符 BETWEEN区间条件查询 1SELECT * FROM Emp e WHERE e.Sal BETWEEN 1500 AND 3000; EXISTS判断子查询是否存在，查询性能比IN高 12345SELECT * FROM Emp e WHERE EXISTS (SELECT 1 FROM Dept d WHERE d.Deptno = e.Deptno); GROUP BY分组查询 12345SELECT中所有独立字段必须出现在Group By子句中，否则会报错SELECT e.Deptno ,SUM(e.Sal) FROM Emp e GROUP BY e.Deptno; HAVING条件判断WHERE中不能使用分组计算函数，但HAVING可以，所以常跟GROUP BY连用 12345SELECT e.Deptno ,SUM(e.Sal) FROM Emp eHAVING SUM(e.Sal) &gt; 10000 GROUP BY e.Deptno;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[004-常用]]></title>
    <url>%2FOracle%2F004-%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[赋权1234GRANT ALL ON TABLE_NAME TO APPS;GRANT SELECT ON TABLE_NAME TO APPS;GRANT EXECUTE ON PKG_NAME TO APPS;GRANT SELECT ON TABLE_NAME TO APPS WITH GRANT OPTION; --查询权限和赋权的权限都授予APPS用户 ACLACL设置 1234567BEGIN Dbms_Network_Acl_Admin.Assign_Acl(Acl =&gt; '/sys/acls/WebService.xml' ,Host =&gt; 'erptest001.gz.cvte.cn' ,Lower_Port =&gt; 9081 --允许访问的起始端口号 ,Upper_Port =&gt; NULL --允许访问的截止端口号 );END; ACL查询 12345SELECT Host ,Lower_Port ,Upper_Port ,Acl FROM Sys.Dba_Network_Acls; ACL测试（能查询到数据表示调用成功） 1SELECT Utl_Http.Request('http://pcmcsb.gz.cvte.cn/csb/config/choices/code') FROM Dual; 查询被锁住对象1234567891011121314151617SELECT 'ALTER system kill session ' || '''' || Vs.Sid || ',' || Vs.Serial# || ''';' Execode ,Lo.Session_Id Sid ,Vs.Serial# ,Lo.Locked_Mode 锁模式 ,Ao.Object_Name 被锁对象名 ,Vs.Username 登录用户 ,Vs.Machine 登录机器名 ,Lo.Os_User_Name 登录机器用户名 ,Vs.Terminal 终端用户名 ,Vs.Logon_Time 登录时间 FROM V$locked_Object Lo ,All_Objects Ao ,V$session Vs WHERE Lo.Object_Id = Ao.Object_Id AND Lo.Session_Id = Vs.Sid ORDER BY Vs.Sid ,Vs.Serial#; 查询DDL锁123456789101112131415SELECT s.Sid Sid ,s.Serial# ,s.Inst_Id ,s.Username Username ,s.Machine Machine ,s.Program ,l.* FROM Dba_Ddl_Locks l ,Gv$session sWHERE l.Session_Id = s.Sid AND l.Owner = 'APPS' AND NAME = 'XXGTXP040'ORDER BY s.Logon_Time;--ALTER system kill session '1535,46091'; 清除缓存1234BEGIN EXECUTE IMMEDIATE 'ALTER SYSTEM FLUSH SHARED_POOL'; EXECUTE IMMEDIATE 'ALTER SYSTEM FLUSH BUFFER_CACHE';END; 查询SQL执行消耗1234567SELECT Rank() Over(ORDER BY Elapsed_Time DESC) Rank_Num ,Vs.Sql_Id ,Vs.Sql_Text ,Vs.Elapsed_Time 总耗时 ,Vs.Cpu_Time Cpu耗时 ,Vs.Disk_Reads 磁盘读取 FROM V$sql Vs; 查询执行中的SQL123456789101112131415161718192021SELECT 'ALTER system kill session ' || '''' || b.Sid || ',' || b.Serial# || ''';' Execode ,b.Sid ,b.Serial# ,b.Username 登录用户 ,Spid 操作系统id ,c.Sql_Text 正在执行sql ,b.Schemaname SCHEMA ,b.Username 登录用户 ,b.Machine 登录机器名 ,b.Osuser 登录机器用户名 ,b.Program 发起请求程序 ,d.Cpu_Time 花费cpu的时间 ,b.Status 状态 FROM V$process a ,V$session b ,V$sqlarea c ,V$sql d WHERE a.Addr = b.Paddr AND b.Sql_Hash_Value = c.Hash_Value AND b.Sql_Address = d.Address(+) AND b.Sql_Hash_Value = d.Hash_Value(+); 查询包中参数1234567891011SELECT u.Package_Name 包名 ,u.Object_Name 方法 ,u.Argument_Name 参数 ,u.In_Out 参数模式 ,u.Data_Type 参数类型 ,u.Position 参数位置 FROM Sys.User_Arguments u ORDER BY u.Package_Name ,u.Object_Name ,u.Overload ,u.Sequence; 查询表占用空间12345SELECT t.Bytes ,t.* FROM User_Segments t WHERE t.Bytes IS NOT NULL ORDER BY t.Bytes DESC; 查询包中是否有某语句1SELECT * FROM Sys.All_Source t WHERE Upper(t.Text) LIKE '%%'; 查询对象依赖1SELECT * FROM Sys.Dba_Dependencies t WHERE t.Referenced_Name = 'XXCST_PAC_INV_RPT'; 查询数据库所有对象1234SELECT t.* FROM Sys.Dba_Objects t WHERE 1 = 1 AND t.Object_Name = 'DUAL'; 查询表中列1234567891011121314SELECT Sut.Table_Name ,Sut.Tablespace_Name ,Sutc.Column_Name ,Ucc.Comments ,Sutc.Data_Type ,Sutc.Data_Length ,Sutc.Nullable FROM Sys.User_Tables Sut ,Sys.User_Tab_Cols Sutc ,Sys.User_Col_Comments Ucc WHERE Sut.Table_Name = Sutc.Table_Name AND Ucc.Table_Name = Sutc.Table_Name AND Ucc.Column_Name = Sutc.Column_Name ORDER BY Sutc.Column_Id; 查询表和表描述1234567SELECT t.Table_Name 表名 ,f.Comments 表描述 ,t.Tablespace_Name 表空间名 ,t.Status 状态 FROM User_Tables t INNER JOIN User_Tab_Comments f ON t.Table_Name = f.Table_Name;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[006-优化]]></title>
    <url>%2FOracle%2F006-%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化器（Optimizer） 索引优化避免索引列上的函数避免索引列上的计算公式避免使用 not in， 使用 not exists 代替LIKE 的使用复合索引的使用 减少负荷优化编写可再利用性的 SQL 语句对已经运行过的 SQL 语句会将它放在缓冲池中，当有再次运行时，如存在缓冲池则直接执行，否则需要进行编译解析使用表别名通过对表附加别名， SQL 编译时可以明确列的来源表，从而使得 SQL 的编译时间缩短ROWNUM 的使用UNION 和 UNION ALLUNION 为了去除重复的数据会引起内部排序处理，如果确定不会出现重复数据的话，必须设定 UNION ALL 提高检索速度。替代 DISTINCT]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[007-概念]]></title>
    <url>%2FOracle%2F007-%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[实例/表空间/用户/表区别完整的Oracle数据库通常由两部分组成：Oracle数据库和数据库实例。 数据库是一系列物理文件的集合（数据文件，控制文件，联机日志，参数文件等） Oracle数据库实例则是一组Oracle后台进程/线程以及在服务器分配的共享内存区 在启动Oracle数据库服务器时，实际上是在服务器的内存中创建一个Oracle实例（即在服务器内存中分配共享内存并创建相关的后台内存），然后由这个Oracle数据库实例来访问和控制磁盘中的数据文件。Oracle有一个很大的内存快，成为全局区（SGA）。 数据库数据库是数据集合， 通常情况了我们称的“数据库”即物理数据、内存、操作系统进程的组合体。我们在安装Oracle数据库时，会让我们选择安装启动数据库（即默认的全局数据库）如下图：全局数据库名：就是一个数据库的标识，在安装时就要设置好，以后一般不修改，修改起来也麻烦，因为数据库一旦安装，数据库名就写进了控制文件，数据库表，很多地方都会用到这个数据库名。启动数据库：也叫全局数据库，是数据库系统的入口，它会内置一些高级权限的用户如SYS，SYSTEM等。我们用这些高级权限账号登陆就可以在数据库实例中创建表空间、用户、表。查询当前数据库名： 1select name from v$database; 数据库实例用Oracle官方描述：实例是访问Oracle数据库所需的一部分计算机内存和辅助处理后台进程，是由进程和这些进程所使用的内存(SGA)所构成一个集合。其实就是用来访问和使用数据库的一块进程，它只存在于内存中。就像Java中new出来的实例对象一样。我们访问Oracle都是访问一个实例，但这个实例如果关联了数据库文件，就是可以访问的，如果没有，就会得到实例不可用的错误。实例名指的是用于响应某个数据库操作的数据库管理系统的名称。同时也叫SID。实例名是由参数instance_name决定的。查询当前数据库实例名： 1select instance_name from v$instance; 数据库实例名(instance_name)用于对外部连接。在操作系统中要取得与数据库的联系，必须使用数据库实例名。比如我们作开发，要连接数据库，就得连接数据库实例名： 1jdbc:oracle:thin:@localhost:1521:orcl（orcl就为数据库实例名） 一个数据库可以有多个实例，在作数据库服务集群的时候可以用到。 表空间Oracle数据库是通过表空间来存储物理表的，一个数据库实例可以有N个表空间，一个表空间下可以有N张表。表空间(tablespace)是数据库的逻辑划分，每个数据库至少有一个表空间（称作SYSTEM表空间）。为了便于管理和提高运行效率，可以使用一些附加表空间来划分用户和应用程序。例如：USER表空间供一般用户使用，RBS表空间供回滚段使用。一个表空间只能属于一个数据库。 用户Oracle数据库建好后，要想在数据库里建表，必须先为数据库建立用户，并为用户指定表空间。 schema一个用户一般对应一个schema，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在。好比一个房子，里面放满了家具，对这些家具有支配权的是房子的主人(user)，而不是房子(schema)。你可以也是一个房子的主人(user)，拥有自己的房子(schema).可以通过alter session的方式进入别人的房子。如果你没有特别指定的话，你所做的操作都是针对你当前所在房子中的东西。至于你是否有权限使用(select)、搬动(update)或者拿走(delete)这些家具就看这个房子的主人有没有给你这样的权限了，或者你是整个大厦(DB)的老大(DBA)。 表有了数据库，表空间和用户，就可以用自定义的用户在自己的表空间创建表了。有了表，我们可以开发了。]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[011-MyBatis缓存机制]]></title>
    <url>%2FTools%2F011-MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一级缓存Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只在同SqlSession内有效。在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用同一个Mapper方法，往往只执行一次SQL，因为第一次查询后，MyBatis会将结果放入缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会去查询数据库。每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。具体实现类的类关系图如下图所示。 生命周期 MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象 当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是SqlSession对象仍可使用。 SqlSession中执行了任何一个DML操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用 工作流程 使用缓存条件mybatis认为对于两次查询，如果以下条件都完全一样，那就认为它们是完全相同的两次查询： 传入的statementId 查询时要求的结果集中的结果范围 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串 传递给java.sql.Statement要设置的参数值 配置在MyBatis的配置文件中开启一级缓存value有两个选项： SESSION(默认)：即在同一个会话中执行的所有语句，都会共享这一个缓存 STATEMENT：即只对当前执行的这一个Statement有效（相当于无缓存机制） 1&lt;setting name="localCacheScope" value="SESSION"/&gt; 场景测试场景一：同一数据库会话中，可以看到仅第一次查询了数据库，后面两次都是从一级缓存获取结果场景二：同一数据库会话中，两次查询中间执行了一次插入语句，第二次查询时导致一级缓存失效，重新查询数据库场景三：开启两个会话SqlSession（A和B），当会话B更新了数据之后，会话A并没有读取到新的数据，还是从会话A的缓存获取结果，相反会话B读取到了新的数据，因为更新操作会把会话B缓存清空，会话B重新从数据库获取数据。说明一级缓存只在同一数据库会话内部共享。 小结 一级缓存在同一个SqlSession下共用缓存 一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺 一级缓存再有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement 二级缓存一级缓存其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。 配置在MyBatis的配置文件中开启二级缓存 1&lt;setting name="cacheEnabled" value="true"/&gt; XML文件配置使用二级缓存，例如： 12345678910111213141516171819&lt;!--开启本mapper的namespace下的二级缓存--&gt;&lt;!-- eviction:代表的是缓存回收策略，目前MyBatis提供以下策略。 (1) LRU,最近最少使用的，一处最长时间不用的对象 (2) FIFO,先进先出，按对象进入缓存的顺序来移除他们 (3) SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象 (4) WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU， 移除最长时间不用的对形象 flushInterval:刷新间隔时间，单位为毫秒，这里配置的是100秒刷新，如果你不配置它，那么当 SQL被执行的时候才会去刷新缓存。 size:引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。 这里配置的是1024个对象 readOnly:只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有 办法修改缓存，他的默认值是false，不允许我们修改--&gt;&lt;cache eviction="LRU" flushInterval="100000" readOnly="true" size="1024"/&gt; 场景测试场景一：关闭了一级缓存的前提下，可以看到会话A第二次查询也没能通过缓存获取数据，因为事物未提交；当关闭了会话A后，会话B第二次查询使用了会话A存下来的缓存。结论：提交完事务后，二级缓存才能对所有会话生效（包括自己）场景二：查询和更新分别在两个不同的namspace，可以看到即使会话C更新且提交了会话，但并没有清除前面查询留下的缓存，导致会话B第二次还是使用了缓存。结论：由于MyBatis的二级缓存是基于namespace的，查询语句所在的namspace无法感应到其他namespace中的语句执行的修改，引发脏数据问题。解决方法：在更新的namspace中关联引用查询的namspace，这样两个映射文件对应的Sql操作就能使用的是同一块缓存了 小结 二级缓存在同一个namespace共用缓存 二级缓存实现了不同SqlSession之间缓存数据的共享，可以通过Cache接口实现类不同的组合，对Cache的可控性也更强 在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻 在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AP]]></title>
    <url>%2FEBS%2FAP%2F</url>
    <content type="text"><![CDATA[AP发票从AP发票到日记账12345678910111213141516171819202122232425262728293031323334353637383940414243444546SELECT Aia.Org_Id 业务实体id ,Aia.Invoice_Id 发票id ,Sup.Vendor_Name 供应商 ,Aia.Invoice_Num 发票编号 ,Aia.Invoice_Date 发票日期 ,Aia.Invoice_Currency_Code 发票币种 ,Aia.Invoice_Amount 发票额 ,Aila.Line_Number 行号 ,Alc.Displayed_Field 类型 ,Aila.Amount 行金额 ,Gjb.Name 批名 ,Gjh.Name 日记账名 ,Gjl.Je_Line_Num 日记账行号 FROM Ap.Ap_Invoices_All Aia LEFT JOIN Ap.Ap_Suppliers Sup ON Sup.Vendor_Id = Aia.Vendor_Id LEFT JOIN Ap.Ap_Invoice_Lines_All Aila ON Aila.Invoice_Id = Aia.Invoice_Id LEFT JOIN Apps.Ap_Lookup_Codes Alc ON Alc.Lookup_Type = 'INVOICE LINE TYPE' AND Alc.Lookup_Code = Aila.Line_Type_Lookup_Code LEFT JOIN Ap.Ap_Invoice_Distributions_All Aida ON Aida.Invoice_Id = Aila.Invoice_Id AND Aida.Invoice_Line_Number = Aila.Line_Number LEFT JOIN Xla.Xla_Events Xe --子分类账 ON Xe.Event_Id = Aida.Accounting_Event_Id LEFT JOIN Xla.Xla_Transaction_Entities Xte --会计事物处理实体 ON Xte.Entity_Id = Xe.Entity_Id LEFT JOIN Xla.Xla_Ae_Headers Xah --子分类账头 ON Xah.Event_Id = Xe.Event_Id LEFT JOIN Xla.Xla_Ae_Lines Xal --子分类账头 ON Xal.Ae_Header_Id = Xah.Ae_Header_Id LEFT JOIN Gl.Gl_Import_References Gir --总帐参考 ON Gir.Reference_5 = Xte.Entity_Id AND Gir.Reference_6 = Xe.Event_Id AND Gir.Reference_7 = Xah.Ae_Header_Id AND Gir.Reference_8 = Xal.Ae_Line_Num LEFT JOIN Gl.Gl_Je_Batches Gjb ON Gjb.Je_Batch_Id = Gir.Je_Batch_Id LEFT JOIN Gl.Gl_Je_Headers Gjh ON Gjh.Je_Header_Id = Gir.Je_Header_Id LEFT JOIN Gl.Gl_Je_Lines Gjl ON Gjl.Je_Header_Id = Gir.Je_Header_Id AND Gjl.Je_Line_Num = Gir.Je_Line_Num WHERE 1 = 1 AND Aia.Invoice_Num = '测试001' 付款123456789101112131415161718192021222324252627SELECT Aca.Amount 金额 ,Aca.Check_Date 日期 ,Aca.Check_Id 主键 ,Aca.Check_Number 编号 ,Aca.Currency_Code 币种 ,Aca.Checkrun_Name 付款处理请求 ,Alc.Description 状态 ,Aca.Vendor_Name 收款人名称 ,Aca.Vendor_Site_Code 地点 ,Aca.Bank_Account_Name 账户名称 ,Aca.Bank_Account_Num 账户 ,Aca.Cleared_Amount 结清额 ,Aca.Cleared_Date 结清日期 --发票 ,Aia.Invoice_Num 发票编号 ,Aip.Amount 已付金额 ,Aip.Accounting_Date Gl日期 ,Aia.Description 摘要 FROM Ap.Ap_Checks_All Aca LEFT JOIN Ap_Lookup_Codes Alc ON Alc.Lookup_Type(+) = 'CHECK STATE' AND Alc.Lookup_Code(+) = Aca.Status_Lookup_Code LEFT JOIN Ap.Ap_Invoice_Payments_All Aip ON Aip.Check_Id = Aca.Check_Id LEFT JOIN Ap.Ap_Invoices_All Aia ON Aia.Invoice_Id = Aip.Invoice_Id WHERE Aca.Check_Number = '17499' 供应商供应商地点地址、银行先创建地址，再关联给不同OU的地点，银行和地点没有关联关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081SELECT Sup.Vendor_Id 供应商id ,Sup.Segment1 供应商编码 ,Sup.Vendor_Name 供应商名称 ,Sup.Vendor_Name_Alt 供应商别名 ,Sup.Vendor_Type_Lookup_Code 供应商类型编码 ,Flv.Meaning 供应商类型 ,Ppf.Full_Name 员工名称 ,Hou.Name 业务实体 ,Assa.Vendor_Site_Id 供应商地点id ,Assa.Vendor_Site_Code 供应商地点编码 ,Assa.Pay_Site_Flag 是否可支付 ,Assa.Vat_Code 税码 ,Assa.Inactive_Date 地点失效日期 ,Hps.Party_Site_Name 供应商地点名称 ,Decode(Hps.Status, 'A', 'Y', 'I', 'N', '') 地点状态 ,Hl.Country 国家 ,Hl.Province 省 ,Hl.City 市 ,Hl.County 区 ,Hl.Street 街道 ,Hl.Address1 || ' ' || Hl.Address2 || ' ' || Hl.Address3 || ' ' || Hl.Address4 地址 ,Ibcount.Currency_Code 银行币种 ,Nvl(Ibcount.Bank_Account_Name, Sup.Vendor_Name) 开户名 ,Ibcount.Bank_Account_Num 银行账号 ,Bank_Hp.Party_Name 银行名称 ,Bank_Br_Hp.Party_Name 银行分行 ,Ibcount.Start_Date 银行帐户起始日期 ,Ibcount.End_Date 银行帐户终止日期 ,Ibcount.Primary_Flag AS 账户主要责任人标识 ,Ibcount.Iao_End_Date AS 账户责任人终止日期 FROM Apps.Ap_Suppliers Sup JOIN Apps.Fnd_Lookup_Values Flv ON Flv.Lookup_Type = 'VENDOR TYPE' AND Flv.Language = 'ZHS' AND Flv.Lookup_Code = Sup.Vendor_Type_Lookup_Code LEFT JOIN Apps.Per_All_People_f Ppf ON Ppf.Person_Id = Sup.Employee_Id AND SYSDATE BETWEEN Ppf.Effective_Start_Date AND Ppf.Effective_End_Date LEFT JOIN Apps.Ap_Supplier_Sites_All Assa --地点关联表 ON Assa.Vendor_Id = Sup.Vendor_Id LEFT JOIN Apps.Hr_Operating_Units Hou ON Hou.Organization_Id = Assa.Org_Id LEFT JOIN Apps.Hz_Party_Sites Hps --地点表 ON Hps.Party_Site_Id = Assa.Party_Site_Id AND Hps.Location_Id = Assa.Location_Id LEFT JOIN Apps.Hz_Locations Hl --地址表 ON Hl.Location_Id = Assa.Location_Id LEFT JOIN (SELECT Ieb.Bank_Id ,Ieb.Branch_Id ,Iep.Payee_Party_Id ,Ieb.Ext_Bank_Account_Id ,Ieb.Bank_Account_Name ,Ieb.Bank_Account_Num ,Uses.Start_Date ,Uses.End_Date ,Ieb.Currency_Code ,Iao.Primary_Flag ,Iao.End_Date Iao_End_Date ,Uses.Order_Of_Preference--优先级 FROM Apps.Iby_Pmt_Instr_Uses_All Uses --银行帐户分配层次关系表 JOIN Apps.Iby_External_Payees_All Iep --银行帐户分配层次关系明细表 ON Iep.Party_Site_Id IS NULL AND Iep.Supplier_Site_Id IS NULL AND Iep.Org_Id IS NULL AND Iep.Payment_Function = 'PAYABLES_DISB' AND Iep.Ext_Payee_Id = Uses.Ext_Pmt_Party_Id AND Uses.Instrument_Type = 'BANKACCOUNT' AND Iep.Payment_Function = Uses.Payment_Function JOIN Apps.Iby_Ext_Bank_Accounts Ieb --银行帐户信息表 ON Ieb.Ext_Bank_Account_Id = Uses.Instrument_Id LEFT JOIN Apps.Iby_Account_Owners Iao --帐户责任人表 ON Iao.Account_Owner_Party_Id = Iep.Payee_Party_Id AND Iao.Ext_Bank_Account_Id = Ieb.Ext_Bank_Account_Id WHERE 1 = 1) Ibcount ON Ibcount.Payee_Party_Id = Sup.Party_Id LEFT JOIN Apps.Hz_Parties Bank_Hp ON Ibcount.Bank_Id = Bank_Hp.Party_Id LEFT JOIN Apps.Hz_Parties Bank_Br_Hp ON Ibcount.Branch_Id = Bank_Br_Hp.Party_Id WHERE 1 = 1 AND Sup.Vendor_Id = 1528; 供应商联系人创建联系人后，可以关联到多个地点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113SELECT Sup.Vendor_Id 供应商id ,Sup.Segment1 供应商编码 ,Sup.Vendor_Name 供应商名称 ,Sup.Vendor_Name_Alt 供应商别名 ,Ctc.Contact_Person 供应商联系人 ,Ctc.Phone_Number 联系人电话 ,Ctc.Fax_Phone_Area_Code 联系人传真 ,Ctc.Fax_Phone_Number 联系人手机 ,Ttt.Party_Site_Name 供应商地点名称 ,Ttt.Address1 || Ttt.Address2 || Ttt.Address3 || Ttt.Address4 地址 FROM Apps.Ap_Suppliers Sup LEFT JOIN Apps.Fnd_Lookup_Values Flv ON Sup.Vendor_Type_Lookup_Code = Flv.Lookup_Code AND Flv.Lookup_Type = 'VENDOR TYPE' AND Flv.Language = 'ZHS' LEFT JOIN (SELECT Hr.Relationship_Id ,Hr.Directional_Flag ,Hr.Subject_Id Subject_Id ,Hr.Object_Id Object_Id ,Hr.Party_Id Party_Id ,Hp.Person_Last_Name Contact_Person ,Hp.Person_First_Name Contact_Title ,Hcpp.Phone_Area_Code Phone_Area_Code ,Hcpp.Phone_Number Phone_Number ,Hcpp.Phone_Extension Phone_Extension ,Hcpf.Phone_Area_Code Fax_Phone_Area_Code ,Hcpf.Phone_Number Fax_Phone_Number ,Hr.End_Date ,Hoc.Job_Title Job_Title ,Hoc.Department Department ,Greatest(Nvl(Hr.Last_Update_Date, To_Date('1990101', 'YYYYMMDD')) ,Nvl(Hcpp.Last_Update_Date, To_Date('1990101', 'YYYYMMDD')) ,Nvl(Hcpf.Last_Update_Date, To_Date('1990101', 'YYYYMMDD')) ,Nvl(Hp.Last_Update_Date, To_Date('1990101', 'YYYYMMDD'))) Last_Update_Date FROM Apps.Hz_Relationships Hr ,Apps.Hz_Contact_Points Hcpp ,Apps.Hz_Contact_Points Hcpf ,Apps.Hz_Parties Hp ,Apps.Hz_Org_Contacts Hoc WHERE Hr.Object_Id = Hp.Party_Id AND Hcpp.Owner_Table_Id(+) = Hr.Party_Id AND Hcpf.Owner_Table_Id(+) = Hr.Party_Id AND Hr.Object_Type = 'PERSON' AND Hr.Relationship_Code(+) = 'CONTACT' AND Hcpp.Owner_Table_Name(+) = 'HZ_PARTIES' AND Hcpf.Owner_Table_Name(+) = 'HZ_PARTIES' AND Hcpp.Contact_Point_Type(+) = 'PHONE' AND Hcpp.Phone_Line_Type(+) = 'GEN' AND Hcpp.Status(+) = 'A' AND Hcpf.Contact_Point_Type(+) = 'PHONE' AND Hcpf.Phone_Line_Type(+) = 'FAX' AND Hcpf.Status(+) = 'A' AND Hr.Relationship_Id = Hoc.Party_Relationship_Id(+)) Ctc ON Sup.Party_Id = Ctc.Subject_Id LEFT JOIN (SELECT Hps.Party_Site_Name ,Hl.Address1 ,Hl.Address2 ,Hl.Address3 ,Hl.Address4 ,Hl.City City ,Hl.County County ,Hl.State State ,Hl.Province Province ,Hl.Postal_Code Postal_Code ,Hl.Country Country ,Apps.Pos_Profile_Change_Request_Pkg.Format_Address(Hl.Address1 ,Hl.Address2 ,Hl.Address3 ,Hl.Address4 ,Hl.City ,Hl.Postal_Code ,Hl.State ,Hl.Province ,Hl.County ,Hl.Country) Address_Details ,To_Number(NULL) Lov_Swr ,Hps.Party_Site_Id ,To_Number(NULL) Contact_Req_Id ,Hzr.Subject_Id ,Hps.Party_Site_Id Party_Address_Id ,Hl.Location_Id ,Hps.Party_Id ,Apps.Fnd_Message.Get_String('POS', 'POS_SP_STATUS_CURRENT') Status ,'Current' Image_Swr ,Hzr.Subject_Type ,Hzr.Subject_Table_Name ,Hzr.Relationship_Id FROM Apps.Hz_Party_Sites Hps ,Apps.Hz_Locations Hl ,Apps.Hz_Relationships Hzr WHERE Hps.Location_Id = Hl.Location_Id AND Nvl(Hps.End_Date_Active, SYSDATE) &gt;= SYSDATE AND Hzr.Relationship_Type = 'CONTACT' AND Hzr.Relationship_Code = 'CONTACT_OF' AND Hzr.Subject_Type = 'PERSON' AND Hzr.Subject_Table_Name = 'HZ_PARTIES' AND Hzr.Object_Type = 'ORGANIZATION' AND Hzr.Object_Table_Name = 'HZ_PARTIES' AND Hzr.Status = 'A' AND Hps.Party_Id = Hzr.Object_Id AND EXISTS (SELECT 1 FROM Apps.Ap_Supplier_Contacts Ascs WHERE (Ascs.Inactive_Date IS NULL OR Ascs.Inactive_Date &gt; SYSDATE) AND Hzr.Relationship_Id = Ascs.Relationship_Id AND Hzr.Party_Id = Ascs.Rel_Party_Id AND Hps.Party_Site_Id = Ascs.Org_Party_Site_Id AND Hzr.Subject_Id = Ascs.Per_Party_Id)) Ttt ON Sup.Party_Id = Ttt.Party_Id AND Ctc.Object_Id = Ttt.Subject_Id WHERE 1 = 1 AND Contact_Req_Id IS NULL AND Sup.Vendor_Id = 1528; 付款条件12345678910111213141516171819SELECT Att.Term_Id 付款条件id ,Att.Name 名称 ,Att.Description 摘要 ,Att.Due_Cutoff_Day 截止日 ,Att.Rank 等级 ,Att.Start_Date_Active 有效日期从 ,Att.End_Date_Active 有效日期至 ,Att.Attribute1 是否涉及预付款 ,Atl.Due_Percent "到期%" ,Atl.Due_Amount 金额 ,Atl.Calendar 日历 ,Atl.Fixed_Date 固定日期 ,Atl.Due_Days 天数 ,Atl.Due_Day_Of_Month 日 ,Atl.Due_Months_Forward 提前月数 FROM Ap.Ap_Terms_Tl Att LEFT JOIN Ap.Ap_Terms_Lines Atl ON Atl.Term_Id = Att.Term_Id WHERE Att.Language = 'ZHS']]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APP]]></title>
    <url>%2FEBS%2FAPP%2F</url>
    <content type="text"><![CDATA[弹性域说明性弹性域 路径：应用开发员=&gt;弹性域=&gt;说明性=&gt;注册 应用：选择注册的应用 名称：自定义唯一，弹性域的名称 标题：弹性域窗口的标题 表应用：注册表指定的应用 表名：选择注册的表名称 结构列：用于存放上下文的值，必须是存在于注册过的列，一般用：ATTRIBUTE_CATEGORY 上下文提示：弹性域窗口上下文字段标题 &gt;参考字段字段名：表字段、环境变量等作用：根据参考字段的值显示对应的弹性域段&gt;列显示注册后的列字段（ATTRIBUTE），如果填写了结构列字段，则这里面将不在显示结构列字段，因为系统认为结构列字段与弹性字段是不同的，如果某字段不需要可以取消勾选启用，这样在构造弹性域时此字段不会显示&gt;段值集：手动创建的上下文字段值中代码的值集，选择的值会保存在结构列中默认值： 此处LOV的数据来源于上下文段值的“代码”，打开弹性域窗口时默认带出的上下文默认值参考字段：此处LOV的数据来源于在弹性域里的“参考字段”，根据参考字段的值显示对应的弹性域段必需：上下文是否必需显示：上下文是否显示与参考字段同步：如果输入了参考字段，则需要勾选上下文可以定义多个弹性域段（上下文字段值–代码），每个弹性域段都有一个默认的段定义Global Data Elements，如果我们定义的弹性域只有一种段结构的话，可以直接在Global Data Elements段中进行定义，如果有多个的话，需要在另外创建，需要注意的是一旦弹性域字段在Global Data Elements中定义了，那么在其他创建的弹性域段中则选不到此字段&gt;段摘要编号：序号名称：唯一，标识列的名称窗口提示：弹性域窗口字段标题列：注册到数据库的列名TIPS：上下文在界面处理逻辑： 表关联1234567891011121314151617181920212223242526272829303132333435363738SELECT Fdfv.Application_Id 应用id ,Fav.Application_Name 应用产品 ,Fdfv.Descriptive_Flexfield_Name 弹性域名称 ,Fdfv.Title 标题 ,Fdfv.Description 说明 ,Fdfv.Table_Application_Id 表应用id ,Fdfv.Application_Table_Name 表名 ,Fdfv.Context_Column_Name 结构列 ,Fdfv.Form_Context_Prompt 上下文提示 ,Fdfv.Concatenated_Segs_View_Name Dfv视图名称 ,Fdfv.Protected_Flag 保护 -- ,Fdfcv.Descriptive_Flex_Context_Code 结构代码 ,Fdfcv.Description 名称 ,Fdfcv.Descriptive_Flex_Context_Name 说明 ,Fdfcv.Enabled_Flag 启用 -- ,Fdfcuv.Column_Seq_Num 编号 ,Fdfcuv.End_User_Column_Name 名称 ,Fdfcuv.Form_Left_Prompt 窗口提示 ,Fdfcuv.Application_Column_Name 列名 ,Fdfcuv.Display_Flag 显示 ,Fdfcuv.Enabled_Flag 启用 ,Fdfcuv.Flex_Value_Set_Id 值集id FROM Apps.Fnd_Descriptive_Flexs_Vl Fdfv JOIN Apps.Fnd_Application_Vl Fav ON Fav.Application_Id = Fdfv.Application_Id LEFT JOIN Apps.Fnd_Descr_Flex_Contexts_Vl Fdfcv --段 ON Fdfcv.Application_Id = Fdfv.Application_Id AND Fdfcv.Descriptive_Flexfield_Name = Fdfv.Descriptive_Flexfield_Name LEFT JOIN Apps.Fnd_Descr_Flex_Col_Usage_Vl Fdfcuv --段摘要 ON Fdfcuv.Application_Id = Fdfcv.Application_Id AND Fdfcuv.Descriptive_Flexfield_Name = Fdfcv.Descriptive_Flexfield_Name AND Fdfcuv.Descriptive_Flex_Context_Code = Fdfcv.Descriptive_Flex_Context_Code WHERE 1 = 1 AND Fdfv.Application_Id = 401 --&amp; AND Fdfv.Descriptive_Flexfield_Name = 'MTL_SYSTEM_ITEMS' --&amp; AND Fdfcv.Descriptive_Flex_Context_Code = 'Global Data Elements' --&amp; 键弹性域与”说明性弹性域”属于表单的用户”补充 段”不同的是，”键弹性域”本身就属于系统表单”不可或缺”的标准段参与业务流程的构建 应用：选择注册的应用 代码：自定义唯一，最多四个字符，弹性域CODE 标题：弹性域窗口的标题 表应用：注册表指定的应用 表名：选择注册的表名称 结构列：必须是注册过的列，结构列的用处是存放键弹性域使用的是哪个段结构的代码 唯一标识列：键弹性域唯一标识列，必须是注册过的列 表关联1234567891011121314151617181920212223242526272829303132333435SELECT Fif.Application_Id 应用id ,Fav.Application_Name 应用产品 ,Fif.Id_Flex_Code 代码 ,Fif.Id_Flex_Name 标题 ,Fif.Description 说明 ,Fif.Table_Application_Id 表应用id ,Fif.Application_Table_Name 表名 ,Fif.Unique_Id_Column_Name 唯一标识列 ,Fif.Set_Defining_Column_Name 结构列 ,Fif.Concatenated_Segs_View_Name Kfv视图名称 ,Fifsv.Id_Flex_Num 序号 ,Fifsv.Id_Flex_Structure_Code 结构代码 ,Fifsv.Enabled_Flag 启用 ,Fifsv.Description 说明 ,Fifsvv.Segment_Num 编号 ,Fifsvv.Segment_Name 名称 ,Fifsvv.Description 说明 ,Fifsvv.Application_Column_Name 列名 ,Fifsvv.Display_Flag 显示 ,Fifsvv.Enabled_Flag 启用 ,Fifsvv.Flex_Value_Set_Id 值集id FROM Apps.Fnd_Id_Flexs Fif JOIN Apps.Fnd_Application_Vl Fav ON Fav.Application_Id = Fif.Application_Id LEFT JOIN Apps.Fnd_Id_Flex_Structures_Vl Fifsv --段 ON Fifsv.Application_Id = Fif.Application_Id AND Fifsv.Id_Flex_Code = Fif.Id_Flex_Code LEFT JOIN Apps.Fnd_Id_Flex_Segments_Vl Fifsvv --段摘要 ON Fifsvv.Application_Id = Fifsv.Application_Id AND Fifsvv.Id_Flex_Code = Fifsv.Id_Flex_Code AND Fifsvv.Id_Flex_Num = Fifsv.Id_Flex_Num WHERE 1 = 1 AND Fif.Application_Id = 401 --&amp; AND Fif.Id_Flex_Code = 'MSTK' --&amp; AND Fifsv.Id_Flex_Num = 101 --&amp; 值集1234567891011121314151617SELECT Ffvs.Flex_Value_Set_Id 值集id ,Ffvs.Flex_Value_Set_Name 值集名 ,Ffvs.Description 说明 ,Ffvs.Parent_Flex_Value_Set_Id 父级值集id ,Ffvv.Parent_Flex_Value_Low 父级值集值 ,Ffvv.Flex_Value_Id 值id ,Ffvv.Flex_Value 值 ,Ffvv.Flex_Value_Meaning 转换的值 ,Ffvv.Description 说明 FROM Apps.Fnd_Flex_Value_Sets Ffvs LEFT JOIN Apps.Fnd_Flex_Values_Vl Ffvv ON Nvl(Ffvv.Enabled_Flag, 'N') = 'Y' AND SYSDATE BETWEEN Nvl(Ffvv.Start_Date_Active, SYSDATE) AND Nvl(Ffvv.End_Date_Active, SYSDATE) AND Ffvv.Flex_Value_Set_Id = Ffvs.Flex_Value_Set_Id WHERE Ffvs.Flex_Value_Set_Name = 'CVTE_COA_DEPARTMENT' --&amp; AND Ffvv.Parent_Flex_Value_Low = '10' --&amp; 安全性规则12345678910111213141516171819202122232425SELECT (SELECT Ffvs.Flex_Value_Set_Name FROM Apps.Fnd_Flex_Value_Sets Ffvs WHERE Ffvs.Flex_Value_Set_Id = Ffvrv.Flex_Value_Set_Id) 值集名称 ,Ffvrv.Flex_Value_Rule_Id 规则id ,Ffvrv.Flex_Value_Rule_Name 名称 ,Ffvrv.Description 说明 ,Ffvrv.Error_Message 消息 ,Decode(Ffvrl.Include_Exclude_Indicator, 'I', '包括', 'E', '排除') 类型 ,Ffvrl.Flex_Value_Low 类型自 ,Ffvrl.Flex_Value_High 类型至 ,(SELECT Fav.Application_Name FROM Apps.Fnd_Application_Vl Fav WHERE Fav.Application_Id = Ffvru.Application_Id) 应用产品 ,(SELECT Frv.Responsibility_Name FROM Apps.Fnd_Responsibility_Vl Frv WHERE Frv.Responsibility_Id = Ffvru.Responsibility_Id) 责任名 FROM Apps.Fnd_Flex_Value_Rules_Vl Ffvrv LEFT JOIN Apps.Fnd_Flex_Value_Rule_Lines Ffvrl ON Ffvrv.Flex_Value_Set_Id = Ffvrl.Flex_Value_Set_Id AND Ffvrv.Flex_Value_Rule_Id = Ffvrl.Flex_Value_Rule_Id LEFT JOIN Apps.Fnd_Flex_Value_Rule_Usages Ffvru ON Ffvru.Flex_Value_Set_Id = Ffvrl.Flex_Value_Set_Id AND Ffvru.Flex_Value_Rule_Id = Ffvrl.Flex_Value_Rule_Id WHERE 1 = 1 AND Ffvrv.Flex_Value_Set_Id = 1014895 --&amp; 快速编码123456789101112131415161718192021222324SELECT Fltv.View_Application_Id 应用id ,Fav.Application_Name 应用产品 ,Fltv.Lookup_Type 类型 ,Fltv.Customization_Level 访问级别 ,Fltv.Security_Group_Id 安全组 ,Fltv.Meaning 含义 ,Fltv.Description 说明 ,Flv.Lookup_Code 代码 ,Flv.Meaning 含义 ,Flv.Description 说明 FROM Apps.Fnd_Lookup_Types_Vl Fltv JOIN Apps.Fnd_Application_Vl Fav ON Fav.Application_Id = Fltv.View_Application_Id LEFT JOIN Apps.Fnd_Lookup_Values Flv ON Flv.Language = 'ZHS' AND Nvl(Flv.Enabled_Flag, 'N') = 'Y' AND SYSDATE BETWEEN Nvl(Flv.Start_Date_Active, SYSDATE) AND Nvl(Flv.End_Date_Active, SYSDATE) AND Flv.Lookup_Type = Fltv.Lookup_Type AND Fltv.View_Application_Id = Flv.View_Application_Id AND Fltv.Security_Group_Id = Flv.Security_Group_Id WHERE Fltv.Lookup_Type = 'WIP_JOB_STATUS' --&amp; AND Fltv.View_Application_Id = 700 --&amp; AND Fltv.Security_Group_Id = 0 --&amp; 12345678SELECT Flv.* FROM Apps.Fnd_Lookup_Values Flv WHERE Flv.Lookup_Type = 'CSB_IAC_PROJECT_MAPPING' AND Flv.Language = 'ZHS' AND Nvl(Flv.Enabled_Flag, 'N') = 'Y' AND SYSDATE BETWEEN Nvl(Flv.Start_Date_Active, SYSDATE) AND Nvl(Flv.End_Date_Active, SYSDATE) AND Flv.Tag = 'PROJ-SD' 币种123456789101112SELECT Fc.Currency_Code 代码 ,Fct.Name 名称 ,Fct.Description 说明 ,Fc.Issuing_Territory_Code 发行地区 ,Fc.Symbol 符号 ,Fc.Precision 精度 ,Fc.Start_Date_Active 有效开始时间 ,Fc.End_Date_Active 有效结束时间 FROM Apps.Fnd_Currencies Fc JOIN Apps.Fnd_Currencies_Tl Fct ON Fc.Currency_Code = Fct.Currency_Code AND Fct.Language = 'ZHS';]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OM]]></title>
    <url>%2FEBS%2FOM%2F</url>
    <content type="text"><![CDATA[销售订单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687WITH Cust_Ship_Tb AS (SELECT Hp.Party_Name ,Hca.Account_Number ,Hca.Cust_Account_Id ,Hcsu.Site_Use_Id ,Hcsu.Location ,Hl.Address1 Address FROM Ar.Hz_Parties Hp LEFT JOIN Ar.Hz_Cust_Accounts Hca ON Hca.Party_Id = Hp.Party_Id LEFT JOIN Ar.Hz_Cust_Acct_Sites_All Hcas ON Hcas.Cust_Account_Id = Hca.Cust_Account_Id LEFT JOIN Ar.Hz_Cust_Site_Uses_All Hcsu ON Hcsu.Cust_Acct_Site_Id = Hcas.Cust_Acct_Site_Id LEFT JOIN Ar.Hz_Party_Sites Hps ON Hps.Party_Site_Id = Hcas.Party_Site_Id LEFT JOIN Ar.Hz_Locations Hl ON Hl.Location_Id = Hps.Location_Id),Cust_Bill_Tb AS (SELECT Hcsu.Site_Use_Id ,Hcsu.Location ,Hl.Address1 Address FROM Ar.Hz_Cust_Acct_Sites_All Hcas LEFT JOIN Ar.Hz_Cust_Site_Uses_All Hcsu ON Hcsu.Cust_Acct_Site_Id = Hcas.Cust_Acct_Site_Id LEFT JOIN Ar.Hz_Party_Sites Hps ON Hps.Party_Site_Id = Hcas.Party_Site_Id LEFT JOIN Ar.Hz_Locations Hl ON Hl.Location_Id = Hps.Location_Id)SELECT Ooh.Header_Id 订单头id ,Ooh.Org_Id 业务实体id ,Ott.Name 订单类型 ,Ooh.Order_Number 订单编号 ,Ooh.Cust_Po_Number 客户po ,Ooh.Ordered_Date 订购日期 ,Plht.Name 价目表 ,Ooh.Transactional_Curr_Code 币种 ,Ship_Tb.Party_Name 客户 ,Ship_Tb.Account_Number 客户编号 ,Ship_Tb.Location 收货地点 ,Ship_Tb.Address 收货地址 ,Bill_Tb.Location 收单地点 ,Bill_Tb.Address 收单地址 ,Rtt.Name 付款条件 ,Flv_c.Meaning 订单阶段 -- ,Ool.Line_Id 订单行id ,Ool.Line_Number 行号 ,Ool.Ordered_Item 订购项目 ,Ool.Ordered_Quantity 数量 ,Ool.Unit_Selling_Price 单价 ,Ool.Request_Date 请求日期 ,Ool.Schedule_Ship_Date 计划发运日期 ,Flv_s.Meaning 状态 ,Ottt.Name 行类型 ,Ool.Tax_Code 税分类代码 FROM Ont.Oe_Order_Headers_All Ooh --销售订单头 LEFT JOIN Ont.Oe_Order_Lines_All Ool --销售订单行 ON Ool.Header_Id = Ooh.Header_Id LEFT JOIN Oe_Transaction_Types_Tl Ott ON Ott.Language = 'ZHS' AND Ott.Transaction_Type_Id = Ooh.Order_Type_Id LEFT JOIN Qp.Qp_List_Headers_Tl Plht ON Plht.Language = 'ZHS' AND Plht.List_Header_Id = Ooh.Price_List_Id LEFT JOIN Ar.Ra_Terms_Tl Rtt ON Rtt.Language = 'ZHS' AND Rtt.Term_Id = Ooh.Payment_Term_Id LEFT JOIN Applsys.Fnd_Lookup_Values Flv_c ON Flv_c.Language = 'ZHS' AND Flv_c.Lookup_Type = 'SALES_CHANNEL' AND Flv_c.Lookup_Code = Ooh.Sales_Channel_Code LEFT JOIN Cust_Ship_Tb Ship_Tb --收货方 ON Ship_Tb.Cust_Account_Id = Ooh.Sold_To_Org_Id AND Ship_Tb.Site_Use_Id = Ooh.Ship_To_Org_Id LEFT JOIN Cust_Bill_Tb Bill_Tb --收单方 ON Bill_Tb.Site_Use_Id = Ooh.Invoice_To_Org_Id-- LEFT JOIN Ont.Oe_Transaction_Types_Tl Ottt ON Ottt.Language = 'ZHS' AND Ottt.Transaction_Type_Id = Ool.Line_Type_Id LEFT JOIN Applsys.Fnd_Lookup_Values Flv_s ON Flv_s.Language = 'ZHS' AND Flv_s.Lookup_Type = 'LINE_FLOW_STATUS' AND Flv_s.Lookup_Code = Ool.Flow_Status_Code WHERE 1 = 1 AND Ooh.Order_Number = '1000000122' 事务处理类型12345678910111213141516171819202122232425262728293031323334353637383940414243SELECT Hou.Name 业务实体 ,Flv.Meaning 事务处理类型 ,Ott.Name ,Ott.Description 说明 ,Otta.Start_Date_Active 有效时间从 ,Otta.End_Date_Active 有效时间至 ,(SELECT Flv.Meaning FROM Fnd_Lookup_Values_Vl Flv WHERE Lookup_Type = 'CVTE_OM_BU' AND Enabled_Flag = 'Y' AND SYSDATE BETWEEN Nvl(Start_Date_Active, SYSDATE - 1) AND Nvl(End_Date_Active, SYSDATE + 1) AND Flv.Lookup_Code = Otta.Attribute1) 事业部组 ,Otta.Attribute1 ,Otta.Attribute2 "外销(Y/N)" ,Otta.Attribute3 工单类型 ,Otta.Attribute4 相依贷项行 ,(SELECT Ffvv.Description FROM Fnd_Flex_Values_Vl Ffvv ,Fnd_Flex_Value_Sets Ffvs WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_BU' AND Nvl(Ffvv.Enabled_Flag, 'N') = 'Y' AND SYSDATE BETWEEN Nvl(Ffvv.Start_Date_Active, SYSDATE) AND Nvl(Ffvv.End_Date_Active, SYSDATE) AND Ffvv.Flex_Value = Otta.Attribute5) 毛利分析事业部 ,Otta.Attribute6 需上传合同才能建交付 ,Otta.Attribute7 赠品发货 ,Otta.Attribute8 销售接单统计 ,Otta.Attribute9 开工单是否邮件通知 FROM Oe_Transaction_Types_Tl Ott ,Oe_Transaction_Types_All Otta ,Hr_Organization_Units Hou ,Fnd_Lookup_Values Flv WHERE Otta.Transaction_Type_Id = Ott.Transaction_Type_Id AND Ott.Language = 'ZHS' AND Otta.Org_Id = Hou.Organization_Id(+) AND Flv.Language = 'ZHS' AND Flv.View_Application_Id = 660 AND Flv.Security_Group_Id = 0 AND Flv.Lookup_Code(+) = Otta.Sales_Document_Type_Code AND Flv.Lookup_Type(+) = 'SALES_DOCUMENT_TYPE' AND Otta.Transaction_Type_Id = 1916 --&amp;]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[002-SQL基础]]></title>
    <url>%2FOracle%2F002-SQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[创建表空间创建临时表空间(TIPS：如果建立的是插接式数据库，表空间名、用户名、角色名必须C##打头) 1234567CREATE TEMPORARY TABLESPACE C##APPSTABLESPACE_TEMPTEMPFILE 'D:\Sortware\app\oracle\tablespace\apps\c##appstablespace_temp.dbf'SIZE 32M --初始大小AUTOEXTEND ON --自动扩展NEXT 32M --每次拓展大小MAXSIZE 5G --最大存储值，MAXSIZE UNLIMITED则指不受限制EXTENT MANAGEMENT LOCAL; --EXTENT MANAGEMENT LOCAL(本地管理);EXTENT MANAGEMENT DICTIONARY(数据字典管理) 创建用户表空间 1234567CREATE TABLESPACE C##APPSTABLESPACELOGGING DATAFILE 'D:\Sortware\app\oracle\tablespace\apps\c##appstablespace.dbf'SIZE 32M AUTOEXTEND ON NEXT 32M MAXSIZE 10G EXTENT MANAGEMENT LOCAL; 删除表空间（包括物理数据文件） 1DROP TABLESPACE C##APPSTABLESPACE INCLUDING CONTENTS AND DATAFILES; 创建用户创建用户并指定表空间 123CREATE USER C##APPS IDENTIFIED BY "apps"DEFAULT TABLESPACE C##APPSTABLESPACETEMPORARY TABLESPACE C##APPSTABLESPACE_TEMP; 修改用户密码 1ALTER USER C##APPS IDENTIFIED BY apps; 用户授权(初始创建用户未授权会导致无法登陆) 1234567GRANT CREATE SESSION, CREATE ANY TABLE, CREATE ANY VIEW, CREATE ANY INDEX, CREATE ANY SEQUENCE, CREATE ANY PROCEDURE, ALTER ANY TABLE, ALTER ANY INDEX, ALTER ANY SEQUENCE, ALTER ANY PROCEDURE, DROP ANY TABLE, DROP ANY VIEW, DROP ANY INDEX, DROP ANY SEQUENCE, DROP ANY PROCEDURE, SELECT ANY TABLE, INSERT ANY TABLE, UPDATE ANY TABLE, DELETE ANY TABLE, exp_full_database, --导出数据库的权限 imp_full_database --导入数据库的权限 TO C##APPS; 取消用户授权 1REVOKE CREATE ANY TABLE FROM C##APPS; 查看用户权限 12345678910111213SELECT a.Grantee ,a.Granted_Role ,a.Admin_Option ,a.Common FROM Dba_Role_Privs a WHERE a.Grantee = 'C##APPS'UNION ALLSELECT a.Grantee ,a.Privilege ,a.Admin_Option ,a.Common FROM Dba_Sys_Privs a WHERE a.Grantee = 'C##APPS'; 删除用户 1DROP USER C##APPS CASCADE; --cascade参数是级联删除该用户所有对象 创建角色三种标准的角色：CONNECT、RESOURCE、DBA查看角色权限 1SELECT * FROM Role_Sys_Privs WHERE Role = 'RESOURCE'; 创建角色 1CREATE ROLE C##APPS_ROLE; 授权角色 1GRANT CREATE ANY TABLE C##APPS_ROLE; 角色授予用户 1GRANT C##APPS_ROLE TO C##APPS; 取消角色授予用户 1REVOKE C##APPS_ROLE FROM C##APPS; 删除角色 1DROP ROLE C##APPS_ROLE; DDLTABLE创建表 1234567891011CREATE TABLE Tablename(User_Id NUMBER NOT NULL ,User_Name VARCHAR2(10) DEFAULT 'Zts' ,Creation_Date DATE DEFAULT SYSDATE NOT NULL ,Created_By NUMBER DEFAULT -1 NOT NULL ,Last_Updated_By NUMBER DEFAULT -1 NOT NULL ,Last_Update_Date DATE DEFAULT SYSDATE NOT NULL ,Last_Update_Login NUMBER ,Fictitious AS(User_Id * 10) Virtual --虚拟列 --虚拟列可以用在select，update，delete语句的where条件中，但是不能用于DML语句 --可以基于虚拟列来做分区、建索引、建约束 ); 表/列说明 12COMMENT ON TABLE tablename IS '表名';COMMENT ON COLUMN tablename.user_id IS '列说明'; 复制表(只复制表结构，不复制表数据) 12CREATE TABLE new_tablename AS SELECT * FROM tablename WHERE 1 = 2; 添加、更改、删除列，修改列名，添加虚拟列 12345ALTER TABLE tablename ADD remarks NUMBER;ALTER TABLE tablename MODIFY remarks Varchar2(4000);ALTER TABLE tablename DROP COLUMN remarks;ALTER TABLE tablename RENAME COLUMN remarks TO remark;ALTER TABLE tablename ADD (fictitious AS (user_id * 10)); --虚拟列 删除表 1DROP TABLE tablename; 更改表名 1RENAME tablename TO new_tablename; 临时表PRESERVE：会话断开后数据会自动删除DELETE：COMMIT后会自动删除 1CREATE Global Temporary TABLE Temptable(Id NUMBER) ON COMMIT PRESERVE/DELETE ROWS; VIEW创建视图 12CREATE OR REPLACE VIEW tablename_v AS SELECT * FROM tablename; 删除视图 1DROP VIEW tablename_v; SEQUENCE创建序列 1234567CREATE SEQUENCE tablename_sNOMINVALUE --无最小值NOMAXVALUE --无最大值START WITH 1 --从1开始INCREMENT BY 1 --增量1NOCYCLE --序列不循环 CACHE 20; --指定Cache值 修改序列 123456ALTER SEQUENCE tablename_sMINVALUE 0 --最小值MAXVALUE 40 --最大值 INCREMENT BY 2 --增量NCYCLE --序列循环(设置为循环时必须有最大最小值)NOCACHE; --无Cache值 删除序列 1DROP SEQUENCE tablename_s; INDEX创建索引 123456--唯一性索引CREATE UNIQUE INDEX tablename_u1 ON tablename(user_id);--普通索引CREATE INDEX tablename_n1 ON tablename(user_name);--创建函数索引CREATE INDEX tablename_upper_n1 ON tablename(UPPER(user_name)); TIPS：什么样的情况下不适合创建索引 被查询的表本身就很小，即是是全表扫描也非常快 基于这张表的查询，大多数情况下需要获取的数据量都超过了总量的4% 这张表需要频繁的被更新，建立索引的话会引起索引的频繁更新，从而反而降低数据库的整体效率 SYNONYM创建同义词 1CREATE SYNONYM new_tablename FOR tablename; 删除同义词 1DROP SYNONYM new_tablename; DMLSELECT查询 123456SELECT e.Empno 工号 ,e.Ename "姓名" ,e.Job AS "职位" ,Nvl(e.Deptno, 0) 部门编号 ,(SELECT d.Dname FROM Dept d WHERE d.Deptno = e.Deptno) 部门名称 FROM Emp e; INSERT插入 1INSERT INTO Tablename (User_Id, User_Name) VALUES (Tablename_s.Nextval, 'Zts'); 复制另一个表数据 1INSERT INTO New_Tablename SELECT * FROM Tablename; UPDATE更新 1UPDATE Tablename SET User_Name = 'Zts' WHERE User_Id = 1; DELETE/TRUNCATE删除 12DELETE Tablename WHERE User_Id = 1;TRUNCATE TABLE Tablename; --Truncate只能删除一整个表的数据且无法回滚（谨慎使用） DQLDECODE条件判断 1SELECT Decode(e.Deptno, 10, 'ACCOUNTING', 20, 'RESEARCH', 'SALES') FROM Emp e; CASE条件判断 123456789SELECT (CASE e.Deptno WHEN 10 THEN 'ACCOUNTING' WHEN 20 THEN 'RESEARCH' ELSE 'SALES' END) Dname FROM Emp e; WITHWITH相当于把查询出来的数据存到临时表，后续查询直接从临时表里查询，能适当提高查询效率 12345678WITH Tb1 AS (SELECT e.Empno FROM Emp e WHERE e.Sal &gt; 1500), Tb2 AS (SELECT e.Empno FROM Emp e WHERE e.Deptno &lt;&gt; 10)SELECT * FROM Tb1 ,Tb2 WHERE Tb1.Empno = Tb2.Empno; LIKE模糊匹配‘ _ ‘ 代表单个字符‘ % ‘ 代表0个或多个字符 1SELECT e.* FROM Emp e WHERE e.Ename LIKE '_M%'; ESCAPE使’ % ‘ 和 ‘ _ ‘不作为通配符使用 1SELECT * FROM Emp e WHERE e.Ename LIKE '%\%%' ESCAPE '\'; --使\后面的%不作为通配符 BETWEEN区间条件查询 1SELECT * FROM Emp e WHERE e.Sal BETWEEN 1500 AND 3000; EXISTS判断子查询是否存在，查询性能比IN高 12345SELECT * FROM Emp e WHERE EXISTS (SELECT 1 FROM Dept d WHERE d.Deptno = e.Deptno); GROUP BY分组查询 12345SELECT中所有独立字段必须出现在Group By子句中，否则会报错SELECT e.Deptno ,SUM(e.Sal) FROM Emp e GROUP BY e.Deptno; HAVING条件判断WHERE中不能使用分组计算函数，但HAVING可以，所以常跟GROUP BY连用 12345SELECT e.Deptno ,SUM(e.Sal) FROM Emp eHAVING SUM(e.Sal) &gt; 10000 GROUP BY e.Deptno;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[002-进阶]]></title>
    <url>%2FOracle%2F002-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[字段约束约束类型： UNIQUE (唯一性约束) NOT NULL (非空约束) CHECK (自定义约束) PRIMARY KEY (主键约束) FOREIGN KEY (外键约束) 外键策略： 默认：存在外键的主键表列数据不允许被删除 ON DELETE CASCADE：级联删除，主键表列数据被删除时，外键表对应列数据也被删除 ON DELETE SET NULL：主键表列数据被删除时，外键表对应列数据会变成null 创建表时同时创建约束 1234567891011--主键表CREATE TABLE Tablenamepk(User_Id NUMBER Primary Key --主键约束 ,User_Name VARCHAR2(20) NOT NULL --非空约束 ,Deptno VARCHAR2(10) UNIQUE --唯一性约束 ,Sal NUMBER CHECK(Sal BETWEEN 1 AND 100) --自定义约束 );--外键表CREATE TABLE Tablenamefk(User_Id NUMBER ,CONSTRAINT Tablenamefk_Fk Foreign Key(User_Id) References Tablenamepk(User_Id) ON DELETE Cascade --Tablenamepk(user_id)必须是主键约束或唯一性约束 ); 单独创建约束(增加主外键约束用Add，其他用Modify ) 123ALTER TABLE Tablenamepk Modify Deptno NOT NULL; ALTER TABLE Tablenamepk Add CONSTRAINT Tablenamepk_Pk Primary Key(User_Id);ALTER TABLE Tablenamefk Add CONSTRAINT Tablenamefk_Fk Foreign Key(User_Id) References Tablenamepk(User_Id) ON DELETE SET NULL; 失效\启用\ 删除约束 123ALTER TABLE Tablenamefk DISABLE CONSTRAINT Tablenamefk_Fk;--失效ALTER TABLE Tablenamefk ENABLE CONSTRAINT Tablenamefk_Fk; --启用ALTER TABLE Tablenamefk DROP CONSTRAINT Tablenamefk_Fk; --删除 临时表临时表中保存的数据只对当前会话有效，即使提交了事务在别的会话中也看不到数据 会话级-PRESERVE：会话临时表执行commit和rollback操作得到效果和一般表是一样的，但是表中数据只在会话生命周期之中存在，当用户退出会话结束的时候，Oracle自动清除临时表中数据 事务级-DELETE：执行commit和rollback操作时会清除表中数据 1CREATE Global Temporary TABLE Temptable(Id NUMBER) ON COMMIT PRESERVE/DELETE ROWS; 分区表优点： 改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度 增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用 维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可 均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能 缺点：已经存在的表没有方法可以直接转化为分区表 范围分区表每一个分区都必须有一个VALUES LESS THEN子句，分区键的任何值等于或者大于这个上限值的记录都会被加入到下一个的分区中。除了第一个分区，其他分区都会有一个隐式的下限值，这个值就是此分区的前一个分区的上限值。如果指定MAXVALUE，这个值高于其它分区中的任何分区键的值，同时包括空值。 12345678910111213CREATE TABLE Area_Range( Range_Key DATE --分区字段，根据插入数值自动存入对应分区 ,User_Id NUMBER ,User_Name VARCHAR2(240) ) PARTITION BY RANGE(Range_Key) INTERVAL(NUMTOYMINTERVAL(1,'MONTH')) --每个月系统自动生成一个分区,使用之后不能再用MAXVALUE --根据年月：NUMTOYMINTERVAL(n ,&#123;'YEAR'|'MONTH'&#125;) --根据天时分秒：NUMTODSINTERVAL(n ,&#123;'DAY'|'HOUR'|'MINUTE'|'SECOND'&#125;) ( PARTITION part20171101 VALUES LESS THAN (TO_DATE('2017-11-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) TABLESPACE tbs01, PARTITION part20171201 VALUES LESS THAN (TO_DATE('2017-12-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) TABLESPACE tbs02 --PARTITION partmax VALUES LESS THAN (MAXVALUE)); 增加分区 12345--有MAXVALUE分区条件时创建分区ALTER TABLE Area_Range SPLIT PARTITION partmax AT (TO_DATE('2018-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'))INTO (PARTITION part20180101, PARTITION partmax) UPDATE GLOBAL INDEXES;--没有maxvalue分区条件时创建分区ALTER TABLE Area_Range ADD PARTITION part20180101 VALUES LESS THAN (TO_DATE('2018-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')); 删除分区 1ALTER TABLE Area_Range DROP PARTITION part20180101; 列表分区表某列的值只有确定的几个，基于这样的特点可以采用列表分区 123456789CREATE TABLE List_Range( List_Key VARCHAR2(10) ,User_Id NUMBER ,User_Name VARCHAR2(240))PARTITION BY LIST(List_Key)( PARTITION part01 VALUES('WIP','INV','PO'), PARTITION part02 VALUES('AP','AR')); 增加分区 1ALTER TABLE List_Range ADD PARTITION part03 VALUES ('OM'); 修改分区列表值 12ALTER TABLE List_Range MODIFY PARTITION part03 ADD VALUES('GL');ALTER TABLE List_Range MODIFY PARTITION part03 DROP VALUES('GL'); 删除分区 1ALTER TABLE List_Range DROP PARTITION part03; 哈希分区表当列的值没有合适的条件时，建议使用散列分区，随机的插入到某个区中，不受人为的干预，因为通过在I/O设备上进行散列分区，使得这些分区大小一致 123456789CREATE TABLE Hash_Range( Hash_Key VARCHAR2(10) ,User_Id NUMBER ,User_Name VARCHAR2(240)) PARTITION BY HASH(Hash_Key)( PARTITION part01, PARTITION part02); 增加分区 1ALTER TABLE Hash_Range ADD PARTITION part03; 删除分区一次减少一个，不能指定减少partition的名称 1ALTER TABLE Hash_Range COALESCE PARTITION; 其他操作查询指定分区 1SELECT * FROM Area_Range PARTITION(Part20171201); 查询分区信息 1SELECT * FROM Sys.User_Tab_Partitions t WHERE t.Tablespace_Name = 'APPS' AND t.Table_Name = 'AREA_RANGE'; 分区合并 12ALTER TABLE Area_Range MERGE PARTITIONS part20171101,part20171201 INTO PARTITION part20171201UPDATE INDEXES; 如果分区合并最后没添加update indexes子句的话，可以重建受影响的分区的索引 1ALTER TABLE Area_Range MODIFY PARTITION part20171201 REBUILD UNUSABLE LOCAL INDEXES; 分区改名 1ALTER TABLE Hash_Range RENAME PARTITION PART01 TO PART02; 物化视图物化视图主要是用于分布式数据库，在数据库B中要使用数据库A中a表，先在A数据库建立DBLINK，并在数据库B中创建数据库A中a表的物化视图，提高查询效率刷新方式： FAST:快速刷新，利用SNAPSHOT LOG只更新时间段变动部分 COMPLETE:完全刷新 FORCE:自动判断刷新，介于FAST和COMPLETE之间 如果是FAST方式需要在A数据库建立Snapshot日志，否则跳过此步骤 1CREATE SNAPSHOT Log ON Emp WITH ROWID; 创建物化视图 123CREATE SNAPSHOT C##apps_Emp_c REFRESH COMPLETE START WITH SYSDATE NEXT SYSDATE + 1 AS SELECT * FROM Emp@Tablename_Dbl; 修改物化视图 12ALTER SNAPSHOT C##apps_Emp_c REFRESH COMPLETE START WITH SYSDATE + 1 NEXT SYSDATE + SYSDATE + (1 / (24 * 60)); 查看物化视图最后刷新的日期 1SELECT * FROM All_Snapshot_Refresh_Times; 手动刷新物化视图（F：FAST、C：COMPLETE） 123BEGIN Dbms_Snapshot.Refresh('C##APPS_EMP_C', 'C');END; DBLINK查询用户是否有创建DBLINK权限 1SELECT * FROM User_Sys_Privs WHERE Privilege LIKE Upper('%DATABASE LINK%'); 使用 sysdba 角色给用户赋权 1GRANT CREATE PUBLIC DATABASE LINK TO C##APPS; 创建DBLINKDBLINK分为公有和私有两类，公有dblink对所有人开放，私有dblink只有创建者可以访问。公有DBLINK使用PUBLIC修饰关键字。在CREATE和DROP的时候都需要使用PUBLIC，如：DROP PUBLIC DATABASE LINK 或者DROP DATABASE LINK 123456789101112--方法一：要求数据库服务器 A上tnsnames.ora中有数据库B的映射 CREATE DATABASE LINK TABLENAME_DBL CONNECT TO C##APPS IDENTIFIED BY apps USING 'ORCL';--方法二：直接配置 CREATE DATABASE LINK tablename_dbl CONNECT TO C##APPS IDENTIFIED BY apps USING '(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) )'; DBLINK表查询 1SELECT * FROM tablename@tablename_dbl; 查询已建立的DBLINK 1SELECT * FROM All_Db_Links; 删除DBLINK 1DROP DATABASE LINK tablename_dbl; 定时任务查询定时任务 1234567891011121314SELECT Uj.Job 唯一标示 ,Uj.Log_User 提交用户 ,Uj.Priv_User 赋予任务权限的用户 ,Uj.Schema_User 用户模式 ,Uj.Last_Date 最后运行时间 ,Uj.This_Date 正在运行时间 ,Uj.Next_Date 下一次运行时间 ,Uj.Total_Time 运行总时间 ,Uj.Broken 是否失效 ,Uj.Interval 运行时间间隔 ,Uj.Failures 失败次数 ,Uj.What 执行脚本 ,Uj.Nls_Env 环境参数 FROM Sys.User_Jobs Uj; 设置定时任务 12345678910111213141516171819202122DECLARE Jobno NUMBER;BEGIN --创建 Sys.Dbms_Job.Submit(Job =&gt; Jobno ,What =&gt; 'INSERT INTO TableName VALUES(1);' ,Next_Date =&gt; To_Date('2017-01-01 01:01:01', 'YYYY-MM-DD HH24:MI:SS') ,INTERVAL =&gt; 'SYSDATE+(1/(24*60))'); ----每分钟执行一次 --启动 Dbms_Job.Run(Jobno); --停止 Dbms_Job.Broken(Jobno, TRUE, SYSDATE); --删除 Dbms_Job.Remove(Jobno); --修改执行操作 Dbms_Job.What(Jobno, 'INSERT INTO tablename VALUES (1);'); --修改下次执行时间 Dbms_Job.Next_Date(Jobno, To_Date('2017-01-01 01:01:01', 'YYYY-MM-DD HH24:MI:SS')); --修改间隔时间 Dbms_Job.Interval(Jobno, 'SYSDATE+(1/(24*60))'); COMMIT;END; 表链接(+)外链接，与JION用法类似，区别在于不能实现多表外链接 12345678SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a ,Salgrade b WHERE a.Sal = b.Hisal(+) --a表没(+)表示主表，没匹配上也要显示出来，b表列置空显示 AND a.Deptno = 20; JOINLEFT JOIN左外连接（LEFT OUTER JOIN 或 LEFT JOIN ） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a LEFT JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; RIGHT JOIN右外连接（RIGHT OUTER JOIN 或 RIGHT JOIN） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a RIGHT JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; INNER JOIN内连接，取两表交集（INNER JOIN 或 JOIN） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a INNER JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; FULL JOIN全连接,取两表并集（FULL OUTER JOIN 或 FULL JOIN） 12345678SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a FULL JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal; 全连接,取两表无交集 12345678910SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a FULL JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Sal IS NULL OR b.Hisal IS NULL; CROSS JOIN交叉连接(CROSS JOIN)：结果集是个笛卡尔乘积 123456SELECT e.Empno ,e.Ename ,e.Sal ,s.* FROM Emp e CROSS JOIN Salgrade s; UNION取并集 UNION ：结果集去除重复记录 UNION ALL：结果集保留重复记录 123456789SELECT e.Ename ,e.Empno FROM Emp e WHERE e.Sal &gt; 1500UNIONSELECT e.Ename ,e.Empno FROM Emp e WHERE e.Deptno &lt;&gt; 10; INTERSECT取交集 123456SELECT e.Deptno FROM Emp e WHERE e.Hiredate &gt; To_Date('1982/1/23', 'YYYY-MM-DD HH24:MI:SS')INTERSECTSELECT d.Deptno FROM Dept d; MINUS取差集 1SELECT d.Deptno FROM Dept d MINUS SELECT e.Deptno FROM Emp e; 触发器触发器记录表操作日志 123456789101112131415161718192021222324CREATE OR REPLACE TRIGGER Tablenamelog_Tri AFTER INSERT OR UPDATE OR DELETE ON Tablename FOR EACH ROWDECLARE l_Operation_Type VARCHAR2(10);BEGIN IF Inserting THEN l_Operation_Type := 'INSERT'; ELSIF Updating THEN l_Operation_Type := 'UPDATE'; ELSIF Deleting THEN l_Operation_Type := 'DELETE'; END IF; INSERT INTO Tablename_Log VALUES (l_Operation_Type ,Nvl(:New.User_Id, :Old.User_Id) ,Nvl(:New.User_Name, :Old.User_Name) ,SYSDATE ,-1 ,-1 ,SYSDATE ,-1);END Tablenamelog_Tri;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[003-SQL进阶]]></title>
    <url>%2FOracle%2F003-SQL%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[字段约束约束类型： UNIQUE (唯一性约束) NOT NULL (非空约束) CHECK (自定义约束) PRIMARY KEY (主键约束) FOREIGN KEY (外键约束) 外键策略： 默认：存在外键的主键表列数据不允许被删除 ON DELETE CASCADE：级联删除，主键表列数据被删除时，外键表对应列数据也被删除 ON DELETE SET NULL：主键表列数据被删除时，外键表对应列数据会变成null 创建表时同时创建约束 1234567891011--主键表CREATE TABLE Tablenamepk(User_Id NUMBER Primary Key --主键约束 ,User_Name VARCHAR2(20) NOT NULL --非空约束 ,Deptno VARCHAR2(10) UNIQUE --唯一性约束 ,Sal NUMBER CHECK(Sal BETWEEN 1 AND 100) --自定义约束 );--外键表CREATE TABLE Tablenamefk(User_Id NUMBER ,CONSTRAINT Tablenamefk_Fk Foreign Key(User_Id) References Tablenamepk(User_Id) ON DELETE Cascade --Tablenamepk(user_id)必须是主键约束或唯一性约束 ); 单独创建约束(增加主外键约束用Add，其他用Modify ) 123ALTER TABLE Tablenamepk Modify Deptno NOT NULL; ALTER TABLE Tablenamepk Add CONSTRAINT Tablenamepk_Pk Primary Key(User_Id);ALTER TABLE Tablenamefk Add CONSTRAINT Tablenamefk_Fk Foreign Key(User_Id) References Tablenamepk(User_Id) ON DELETE SET NULL; 失效\启用\ 删除约束 123ALTER TABLE Tablenamefk DISABLE CONSTRAINT Tablenamefk_Fk;--失效ALTER TABLE Tablenamefk ENABLE CONSTRAINT Tablenamefk_Fk; --启用ALTER TABLE Tablenamefk DROP CONSTRAINT Tablenamefk_Fk; --删除 临时表临时表中保存的数据只对当前会话有效，即使提交了事务在别的会话中也看不到数据 会话级-PRESERVE：会话临时表执行commit和rollback操作得到效果和一般表是一样的，但是表中数据只在会话生命周期之中存在，当用户退出会话结束的时候，Oracle自动清除临时表中数据 事务级-DELETE：执行commit和rollback操作时会清除表中数据 1CREATE Global Temporary TABLE Temptable(Id NUMBER) ON COMMIT PRESERVE/DELETE ROWS; 分区表优点： 改善查询性能：对分区对象的查询可以仅搜索自己关心的分区，提高检索速度 增强可用性：如果表的某个分区出现故障，表在其他分区的数据仍然可用 维护方便：如果表的某个分区出现故障，需要修复数据，只修复该分区即可 均衡I/O：可以把不同的分区映射到磁盘以平衡I/O，改善整个系统性能 缺点：已经存在的表没有方法可以直接转化为分区表 范围分区表每一个分区都必须有一个VALUES LESS THEN子句，分区键的任何值等于或者大于这个上限值的记录都会被加入到下一个的分区中。除了第一个分区，其他分区都会有一个隐式的下限值，这个值就是此分区的前一个分区的上限值。如果指定MAXVALUE，这个值高于其它分区中的任何分区键的值，同时包括空值。 12345678910111213CREATE TABLE Area_Range( Range_Key DATE --分区字段，根据插入数值自动存入对应分区 ,User_Id NUMBER ,User_Name VARCHAR2(240) ) PARTITION BY RANGE(Range_Key) INTERVAL(NUMTOYMINTERVAL(1,'MONTH')) --每个月系统自动生成一个分区,使用之后不能再用MAXVALUE --根据年月：NUMTOYMINTERVAL(n ,&#123;'YEAR'|'MONTH'&#125;) --根据天时分秒：NUMTODSINTERVAL(n ,&#123;'DAY'|'HOUR'|'MINUTE'|'SECOND'&#125;) ( PARTITION part20171101 VALUES LESS THAN (TO_DATE('2017-11-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) TABLESPACE tbs01, PARTITION part20171201 VALUES LESS THAN (TO_DATE('2017-12-01 00:00:00','YYYY-MM-DD HH24:MI:SS')) TABLESPACE tbs02 --PARTITION partmax VALUES LESS THAN (MAXVALUE)); 增加分区 12345--有MAXVALUE分区条件时创建分区ALTER TABLE Area_Range SPLIT PARTITION partmax AT (TO_DATE('2018-01-01 00:00:00','yyyy-mm-dd hh24:mi:ss'))INTO (PARTITION part20180101, PARTITION partmax) UPDATE GLOBAL INDEXES;--没有maxvalue分区条件时创建分区ALTER TABLE Area_Range ADD PARTITION part20180101 VALUES LESS THAN (TO_DATE('2018-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS')); 删除分区 1ALTER TABLE Area_Range DROP PARTITION part20180101; 列表分区表某列的值只有确定的几个，基于这样的特点可以采用列表分区 123456789CREATE TABLE List_Range( List_Key VARCHAR2(10) ,User_Id NUMBER ,User_Name VARCHAR2(240))PARTITION BY LIST(List_Key)( PARTITION part01 VALUES('WIP','INV','PO'), PARTITION part02 VALUES('AP','AR')); 增加分区 1ALTER TABLE List_Range ADD PARTITION part03 VALUES ('OM'); 修改分区列表值 12ALTER TABLE List_Range MODIFY PARTITION part03 ADD VALUES('GL');ALTER TABLE List_Range MODIFY PARTITION part03 DROP VALUES('GL'); 删除分区 1ALTER TABLE List_Range DROP PARTITION part03; 哈希分区表当列的值没有合适的条件时，建议使用散列分区，随机的插入到某个区中，不受人为的干预，因为通过在I/O设备上进行散列分区，使得这些分区大小一致 123456789CREATE TABLE Hash_Range( Hash_Key VARCHAR2(10) ,User_Id NUMBER ,User_Name VARCHAR2(240)) PARTITION BY HASH(Hash_Key)( PARTITION part01, PARTITION part02); 增加分区 1ALTER TABLE Hash_Range ADD PARTITION part03; 删除分区一次减少一个，不能指定减少partition的名称 1ALTER TABLE Hash_Range COALESCE PARTITION; 其他操作查询指定分区 1SELECT * FROM Area_Range PARTITION(Part20171201); 查询分区信息 1SELECT * FROM Sys.User_Tab_Partitions t WHERE t.Tablespace_Name = 'APPS' AND t.Table_Name = 'AREA_RANGE'; 分区合并 12ALTER TABLE Area_Range MERGE PARTITIONS part20171101,part20171201 INTO PARTITION part20171201UPDATE INDEXES; 如果分区合并最后没添加update indexes子句的话，可以重建受影响的分区的索引 1ALTER TABLE Area_Range MODIFY PARTITION part20171201 REBUILD UNUSABLE LOCAL INDEXES; 分区改名 1ALTER TABLE Hash_Range RENAME PARTITION PART01 TO PART02; 物化视图物化视图主要是用于分布式数据库，在数据库B中要使用数据库A中a表，先在A数据库建立DBLINK，并在数据库B中创建数据库A中a表的物化视图，提高查询效率刷新方式： FAST:快速刷新，利用SNAPSHOT LOG只更新时间段变动部分 COMPLETE:完全刷新 FORCE:自动判断刷新，介于FAST和COMPLETE之间 如果是FAST方式需要在A数据库建立Snapshot日志，否则跳过此步骤 1CREATE SNAPSHOT Log ON Emp WITH ROWID; 创建物化视图 123CREATE SNAPSHOT C##apps_Emp_c REFRESH COMPLETE START WITH SYSDATE NEXT SYSDATE + 1 AS SELECT * FROM Emp@Tablename_Dbl; 修改物化视图 12ALTER SNAPSHOT C##apps_Emp_c REFRESH COMPLETE START WITH SYSDATE + 1 NEXT SYSDATE + SYSDATE + (1 / (24 * 60)); 查看物化视图最后刷新的日期 1SELECT * FROM All_Snapshot_Refresh_Times; 手动刷新物化视图（F：FAST、C：COMPLETE） 123BEGIN Dbms_Snapshot.Refresh('C##APPS_EMP_C', 'C');END; DBLINK查询用户是否有创建DBLINK权限 1SELECT * FROM User_Sys_Privs WHERE Privilege LIKE Upper('%DATABASE LINK%'); 使用 sysdba 角色给用户赋权 1GRANT CREATE PUBLIC DATABASE LINK TO C##APPS; 创建DBLINKDBLINK分为公有和私有两类，公有dblink对所有人开放，私有dblink只有创建者可以访问。公有DBLINK使用PUBLIC修饰关键字。在CREATE和DROP的时候都需要使用PUBLIC，如：DROP PUBLIC DATABASE LINK 或者DROP DATABASE LINK 123456789101112--方法一：要求数据库服务器 A上tnsnames.ora中有数据库B的映射 CREATE DATABASE LINK TABLENAME_DBL CONNECT TO C##APPS IDENTIFIED BY apps USING 'ORCL';--方法二：直接配置 CREATE DATABASE LINK tablename_dbl CONNECT TO C##APPS IDENTIFIED BY apps USING '(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) )'; DBLINK表查询 1SELECT * FROM tablename@tablename_dbl; 查询已建立的DBLINK 1SELECT * FROM All_Db_Links; 删除DBLINK 1DROP DATABASE LINK tablename_dbl; 定时任务查询定时任务 1234567891011121314SELECT Uj.Job 唯一标示 ,Uj.Log_User 提交用户 ,Uj.Priv_User 赋予任务权限的用户 ,Uj.Schema_User 用户模式 ,Uj.Last_Date 最后运行时间 ,Uj.This_Date 正在运行时间 ,Uj.Next_Date 下一次运行时间 ,Uj.Total_Time 运行总时间 ,Uj.Broken 是否失效 ,Uj.Interval 运行时间间隔 ,Uj.Failures 失败次数 ,Uj.What 执行脚本 ,Uj.Nls_Env 环境参数 FROM Sys.User_Jobs Uj; 设置定时任务 12345678910111213141516171819202122DECLARE Jobno NUMBER;BEGIN --创建 Sys.Dbms_Job.Submit(Job =&gt; Jobno ,What =&gt; 'INSERT INTO TableName VALUES(1);' ,Next_Date =&gt; To_Date('2017-01-01 01:01:01', 'YYYY-MM-DD HH24:MI:SS') ,INTERVAL =&gt; 'SYSDATE+(1/(24*60))'); ----每分钟执行一次 --启动 Dbms_Job.Run(Jobno); --停止 Dbms_Job.Broken(Jobno, TRUE, SYSDATE); --删除 Dbms_Job.Remove(Jobno); --修改执行操作 Dbms_Job.What(Jobno, 'INSERT INTO tablename VALUES (1);'); --修改下次执行时间 Dbms_Job.Next_Date(Jobno, To_Date('2017-01-01 01:01:01', 'YYYY-MM-DD HH24:MI:SS')); --修改间隔时间 Dbms_Job.Interval(Jobno, 'SYSDATE+(1/(24*60))'); COMMIT;END; 表链接(+)外链接，与JION用法类似，区别在于不能实现多表外链接 12345678SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a ,Salgrade b WHERE a.Sal = b.Hisal(+) --a表没(+)表示主表，没匹配上也要显示出来，b表列置空显示 AND a.Deptno = 20; JOINLEFT JOIN左外连接（LEFT OUTER JOIN 或 LEFT JOIN ） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a LEFT JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; RIGHT JOIN右外连接（RIGHT OUTER JOIN 或 RIGHT JOIN） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a RIGHT JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; INNER JOIN内连接，取两表交集（INNER JOIN 或 JOIN） 123456789SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a INNER JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Deptno = 20; FULL JOIN全连接,取两表并集（FULL OUTER JOIN 或 FULL JOIN） 12345678SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a FULL JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal; 全连接,取两表无交集 12345678910SELECT a.Empno ,a.Ename ,a.Sal ,b.* FROM Emp a FULL JOIN Salgrade b ON 1 = 1 AND a.Sal = b.Hisal WHERE a.Sal IS NULL OR b.Hisal IS NULL; CROSS JOIN交叉连接(CROSS JOIN)：结果集是个笛卡尔乘积 123456SELECT e.Empno ,e.Ename ,e.Sal ,s.* FROM Emp e CROSS JOIN Salgrade s; UNION取并集 UNION ：结果集去除重复记录 UNION ALL：结果集保留重复记录 123456789SELECT e.Ename ,e.Empno FROM Emp e WHERE e.Sal &gt; 1500UNIONSELECT e.Ename ,e.Empno FROM Emp e WHERE e.Deptno &lt;&gt; 10; INTERSECT取交集 123456SELECT e.Deptno FROM Emp e WHERE e.Hiredate &gt; To_Date('1982/1/23', 'YYYY-MM-DD HH24:MI:SS')INTERSECTSELECT d.Deptno FROM Dept d; MINUS取差集 1SELECT d.Deptno FROM Dept d MINUS SELECT e.Deptno FROM Emp e; 触发器触发器记录表操作日志 123456789101112131415161718192021222324CREATE OR REPLACE TRIGGER Tablenamelog_Tri AFTER INSERT OR UPDATE OR DELETE ON Tablename FOR EACH ROWDECLARE l_Operation_Type VARCHAR2(10);BEGIN IF Inserting THEN l_Operation_Type := 'INSERT'; ELSIF Updating THEN l_Operation_Type := 'UPDATE'; ELSIF Deleting THEN l_Operation_Type := 'DELETE'; END IF; INSERT INTO Tablename_Log VALUES (l_Operation_Type ,Nvl(:New.User_Id, :Old.User_Id) ,Nvl(:New.User_Name, :Old.User_Name) ,SYSDATE ,-1 ,-1 ,SYSDATE ,-1);END Tablenamelog_Tri;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[003-函数]]></title>
    <url>%2FOracle%2F003-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数字操作函数123456SELECT Trunc(1234.56, 1) "1234.5" --截取 ,Round(1234.56, 1) "1234.6" --四舍五入 ,Ceil(0.4) "1" --向上取整 ,Floor(0.6) "0" --向下取整 ,Abs(-5) "5" --绝对值 FROM Dual; 日期操作函数12345678910111213141516SELECT To_Date('2017-11-11 09:00:00', 'YYYY-MM-DD HH24:MI:SS') 字符转日期 ,SYSDATE - 1 / (24 * 60 * 60) 减去1秒 ,Trunc(SYSDATE) 去除时分秒 ,Trunc(Add_Months(Last_Day(SYSDATE) + 1, -2)) 上月头 ,Trunc(Add_Months(Last_Day(SYSDATE), -1)) 上月末 ,Trunc(Add_Months(Last_Day(SYSDATE) + 1, -1)) 本月头 ,Trunc(Last_Day(SYSDATE)) 本月末 ,Trunc(Add_Months(Last_Day(SYSDATE) + 1, 0)) 下月头 ,Trunc(Last_Day(Add_Months(Last_Day(SYSDATE) + 1, 0))) 下月末 ,Add_Months(SYSDATE, 1) 日期增加或减少n月 ,Months_Between(SYSDATE, SYSDATE - 30) 日期相差月数 ,To_Char(SYSDATE, ' Q') Q季度 ,To_Char(SYSDATE, 'WW') 当年第几周 ,To_Char(SYSDATE, 'DDD') 当年第几天 ,To_Char(SYSDATE, 'W') 本月第几周 FROM Dual; 处理时间间隔NUMTODSINTERVAL单位：’DAY’、’HOUR’、’MINUTE’、’SECOND’ 12SELECT (To_Date('2017-11-11', 'YYYY-MM-DD') + Numtodsinterval(3, 'DAY')) "2017-11-14" FROM Dual; NUMTOYMINTERVAL单位：’YEAR’、’MONTH’ 12SELECT (To_Date('2017-11-11', 'YYYY-MM-DD') + Numtoyminterval(3, 'YEAR')) "2020-11-11" FROM Dual; 字符串操作函数大小写转换 1234SELECT Lower('ORACLE') "sql" --小写 ,Upper('oracle') "SQL" --大写 ,Initcap('ORACLE') "Sql" --首字母大写 FROM Dual; 获取字符串长度 123SELECT Length('ORACLE') "6" --获取字符长度（字母汉字都占1位） ,Lengthb('数据库') "6" --获取字节长度（字母占1位，汉字可能占2位） FROM Dual; 字符串截取 12345SELECT Substr('ORACLE数据库', 7) "数据库" --从第7位往后截取 ,Substr('ORACLE数据库', 7, 1) "数" --从第7位往后截取1位 ,Substr('ORACLE数据库', -3) "数据库" --从倒数第3位往后截取 ,Substrb('ORACLE数据库', 7, 2) "数" --字节截取，如汉字占2位，只截取(7,1)会取到空 FROM Dual; 字符串替换 123SELECT REPLACE('ORACLE数据库', 'ORACLE', 'oracle') "oracle数据库" ,REVERSE('oracle') "'elcaro" --字符反转 FROM Dual; 查找字符串位置 123SELECT Instr('ORACLE数据库', '据', 1, 1) "8" --查找第1位开始，第1次匹配的字符串位置 ,Instrb('ORACLE数据库', '据', 1, 1) "9" --字节查找 FROM Dual; 字符填充 123SELECT Lpad('ORACLE', 10, '*') "****ORACLE" --左填充 ,Rpad('ORACLE', 10, '*') "ORACLE****" --右填充 FROM Dual; NVL1234SELECT Nvl(1, 2) "1" --如果1为空，返回2 ,Nvl2(1, 2, 3) "2" --如果1为空，返回3,否则返回2 ,Nullif(1, 2) "1" --如果1和2相等返回空，不相等返回1 FROM Dual; FOR UPDATE对查询出来的数据加行级锁 FOR UPDATE：如果数据正在被锁定，会等到数据被释放（commit）后才执行锁定 FOR UPDATE NOWAIT：发现数据被锁定，立刻返回报错 1SELECT * FROM Emp FOR UPDATE NOWAIT; 也可用于在PL\SQL DEV中快速DML操作 字符串分割默认用英文逗号分隔，也可以在后面指定分隔符号 1SELECT t.Column_Value FROM TABLE(Split('AAA,BBB,CCC', ',')) t; GREATEST比较数值大小，当存在NULL时，返回NULL 1SELECT Greatest('A', 'B', 'C') "C" FROM Dual; URL编码解码ESCAPE编码 123BEGIN Dbms_Output.Put_Line(Utl_Url.Escape('http://www.google.com/参数=+/', TRUE, 'UTF8'));END; UNESCAPE解码 1234BEGINDbms_Output.Put_Line(Utl_Url.Unescape('http%3A%2F%2Fwww.google.com%2F%E5%8F%82%E6%95%B0%3D%2B%2F' ,'UTF8'));END; 分组排序/计算 RANK：跳跃排序 DENSE_RANK：连续排序 ROW_NUMBER：没有重复值排序 MAX/MIN：分组求最大最小值 LAG： 获取当前记录往前面1行Sal的值，没有则默认值为100 LEAD：获取当前记录往后面1行Sal的值，没有则默认值为100 RATIO_TO_REPORT：计算Sal占总数的比例 123456789101112131415SELECT t.Ename ,t.Job ,t.Sal ,Rank() Over(PARTITION BY t.Job ORDER BY t.Sal) Rank_Num ,Dense_Rank() Over(PARTITION BY t.Job ORDER BY t.Sal) Dense_Num ,Row_Number() Over(PARTITION BY t.Job ORDER BY t.Sal) Row_Num ,MAX(t.Sal) Over(PARTITION BY t.Job) Max_Sal ,MIN(t.Sal) Over(PARTITION BY t.Job) Min_Sal ,Lag(t.Sal, 1, 100) Over(PARTITION BY t.Job ORDER BY t.Sal) Lag_Sal ,Lead(t.Sal, 1, 100) Over(PARTITION BY t.Job ORDER BY t.Sal) Lead_Sal ,SUM(t.Sal) Over(PARTITION BY t.Job) Sum_Sal ,AVG(t.Sal) Over(PARTITION BY t.Job) Avg_Sal ,COUNT(t.Sal) Over(PARTITION BY t.Job) Count_Num ,Ratio_To_Report(t.Sal) Over(PARTITION BY 1) Ratio_Amount FROM Emp t; MERGE用于两个表之间数据的更新同步，基于源表对目标表做Insert，Update，Delete操作 12345678MERGE INTO Targettable tUSING Sourcetable sON (t.Numid = s.Numid) --强制需要括号WHEN MATCHED THEN --匹配 UPDATE SET t.Describtion = s.Describtion DELETE WHERE s.Numid &lt;&gt; t.NumidWHEN NOT MATCHED THEN --不匹配 INSERT VALUES (s.Numid, s.Describtion); TIPS：MERGE为以上固定写法，DELETE只会对MATCHED所有数据进行删除筛选，UPDATE更新后的数据如果符合删除条件，也会被删除 INSERT ALL/FIRST一个来源插入多个目标表FIRST：考虑先后关系，如果有数据满足多个WHEN条件，则只执行第一个WHENALL：不考虑先后关系，只要满足条件就插入 123456INSERT ALL WHEN User_Id = 1 THEN INTO Tablename(User_Id, User_Name) VALUES(Tablename_s.Nextval, '001') ELSE INTO Tablename(User_Id, User_Name) VALUES(Tablename_s.Nextval, '002')SELECT User_Id FROM Tablename; 表结构行转列123456789101112131415--initCREATE TABLE Temp_Emp(Group_Id NUMBER, Line_No NUMBER, Temp VARCHAR2(240));--insertINSERT ALLINTO Temp_Emp(Group_Id, Line_No, Temp) VALUES(Empno, 1, Ename)INTO Temp_Emp(Group_Id, Line_No, Temp) VALUES(Empno, 2, Job)INTO Temp_Emp(Group_Id, Line_No, Temp) VALUES(Empno, 3, Mgr)INTO Temp_Emp(Group_Id, Line_No, Temp) VALUES(Empno, 4, Hiredate)INTO Temp_Emp(Group_Id, Line_No, Temp) VALUES(Empno, 5, Sal)SELECT Empno, Ename, Job, Mgr, Hiredate, Sal FROM Emp;--querySELECT * FROM Temp_Emp t ORDER BY t.Group_Id ,t.Line_No; 执行结果： 行转列按照IN里面的参数进行分列，如果Job能跟IN中参数列对应上，就将Ename放入字段中，注意Ename必须放在聚合函数中 12345678SELECT * FROM (SELECT Empno ,Ename ,Job ,Job Jobtemp FROM Emp t)Pivot(MAX(Ename) FOR Job IN('ANALYST', 'CLERK', 'MANAGER', 'PRESIDENT', 'SALESMAN')); 列转行除Ename列以外的列全部转成行，这些列必须是同一类型，Columnkey和Columnvalue为自定义名字，代表列名和列值 1234567891011121314151617SELECT Ename ,Columnkey ,Columnvalue FROM (SELECT t.Ename ,t.Job ,To_Char(t.Mgr) Mgr ,To_Char(t.Hiredate, 'YYYY-MM-DD HH24:MI:SS') Hiredate ,To_Char(t.Sal) Sal ,To_Char(t.Comm) Comm ,To_Char(t.Deptno) Deptno FROM Emp t) p Unpivot(Columnvalue FOR Columnkey IN(Job ,Mgr ,Hiredate ,Sal ,Comm ,Deptno)) ORDER BY Ename; 字符拼接字符串用逗号分割拼接，长度不能超过4000 1SELECT Wm_Concat(DISTINCT e.Ename) FROM Emp e; 12c以后换成Listagg 1234SELECT e.Deptno ,Listagg(e.Ename, ',') Within GROUP(ORDER BY e.Deptno) FROM Emp e GROUP BY e.Deptno; TIPS：以下两种方法可以实现长度不受限制方法1： 12SELECT TRIM(Xmlagg(Xmlelement(Content, e.Ename || ',') ORDER BY e.Empno).Extract('//text()')) AS Concat FROM Emp e; 方法2： 123456SELECT Dbms_Lob.Substr(Rtrim(Xmlagg(Xmlparse(Content e.Ename || ',' Wellformed) ORDER BY e.Empno) .Getclobval() ,',') ,4000 --自定义大小 ,1) FROM Emp e; 树形遍历向上遍历根节点 123456789SELECT t.Empno ,t.Ename ,t.Mgr ,LEVEL FROM Emp t WHERE 1 = 1 START WITH t.Ename = 'JONES'CONNECT BY Nocycle PRIOR t.Mgr = t.Empno --当前记录的Mgr等于下一条记录的Empno --Nocycle不循环 ORDER BY LEVEL ASC; 向下遍历子节点 12345678910SELECT t.Empno ,t.Ename ,t.Mgr ,Lpad(t.Ename, LEVEL * 5) Tree ,LEVEL FROM Emp t WHERE 1 = 1 START WITH t.Ename = 'JONES'CONNECT BY Nocycle PRIOR t.Empno = t.Mgr --本记录的Empno等于下一条记录的Mgr ORDER BY LEVEL ASC; 随机数123456789SELECT LEVEL Seq_Data ,Trunc(Dbms_Random.Value(1000, 500000), 2) Num_Data ,Decode(Round(Dbms_Random.Value(1, 2)), 1, 'Y', 2, 'N') Flag_Data ,To_Date(Round(Dbms_Random.Value(2000, 2017)) || '-' || Round(Dbms_Random.Value(1, 12)) || '-' || Round(Dbms_Random.Value(1, 28)) ,'YYYY-MM-DD') Date_Data ,Dbms_Random.String('A', Dbms_Random.Value(1, 20)) Str_Data FROM DualCONNECT BY LEVEL &lt; 100; 休眠1DBMS_LOCK.SLEEP(30);--休眠30秒]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[005-安全]]></title>
    <url>%2FOracle%2F005-%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[透明数据加密技术（TDE）TDE - 基于列的加密Oracle TDE的全称是Transparent Data Encryption 透明数据加密。它的优点是对应用透明，管理简便，无需应用设置，但它也有如下限制： 只能使用B-Tree索引 加密的列无法对索引进行rang scan操作。 外部对象 可传输表空间 exp/imp操作 由于有了Oracle的TDE-基于列的加密，你所要做的只是定义需要加密的列，Oracle将为包含加密列的表创建一个私密的安全加密密钥，然后采用你指定的加密算法加密指定列的明文数据。TDE支持的加密算法有：3DES168 、AES128、AES192、AES2561）保证数据库兼容版本高于10gr2，查看数据库版本 1show parameter compatible 2）设定wallet的位置（在sqlnet.ora文件中写入如下内容，需要重启数据库才能生效）： 12345ENCRYPTION_WALLET_LOCATION = (SOURCE= (METHOD=file) (METHOD_DATA= (DIRECTORY=C:\app\xianzhu\product\11.2.0\wallet))) 3）在wallet里面创建key，以下命令将会在对应目录下产生wallet 1alter system set encryption key authenticated by "myPassword"; 4）创建一个表，对其中某列加密 12345--创建表create table tde_private(id number(10), info varchar2(50) encrypt using 'AES192');--查询加密列select * from dba_encrypted_columns; 5）如果关闭wallet，无法访问加密的数据 123456--关闭/打开walletalter system set wallet close/open identified by "myPassword";--关闭时如果进行查询会报错select * from tde_private;第 1 行出现错误:ORA-28365: Wallet 未打开 TDE - 基于表空间的加密这是Oracle 11g推出的新特性，它是对整个表空间进行加密。下面是创建一个加密表空间的语句： 1234567create tablespace encrypted_ts encryption using 'AES256' default storage(encrypt); select tablespace_name,encrypted from dba_tablespaces where tablespace_name='ENCRYPTED_TS'; TABLESPACE_NAME ENC------------------------------ ---ENCRYPTED_TS YES 加密字段 VS 加密表空间表空间加密 是放生在数据存储的时候，也就是存储在文件上的数据已经被加密；字段加密发生在SQL层，由SQL调用一个算法对数据进行加密处理。表空间加密的数据，不会再受到字段加密的限制，比如： 字段类型 索引类型 需要 no salt常见索引 加密表空间的限制： 外部大对象（bfiles)不可以 exp/imp不行，需要用expdp/impdp虚拟私有数据库 （VPD）VPD的全称是Virtual Private Database 虚拟私有数据库，它在Oracle 8i时就出现了，是Oracle比较早期的一种数据安全手段。它是指通过指定策略，对用户的SQL自动添加过滤谓词，以达到对结果集进行过滤的目的，其示意图如下：其大致过程如下：用户发出SQL语句访问表中数据，此时触发定义在该表上的安全策略，该安全策略会在相应的列上加上Where谓词条件，最终返回给用户的是过滤后的结果集。这样用户只能看到自己有权限看到的数据，其效果如下图所示：用户1和用户2虽然发出了两个一模一样的SQL语句，但根据相应的安全策略，他们得到的结果有可能不一样，就像访问自己私有的数据库一样，这也是为什么这项技术叫虚拟私有数据库。1）创建一个函数，该函数定义要加哪些谓词条件：12345create or replace function hide_sal_comm(v_schema varchar2, v_object varchar2) return varchar2 as con varchar2(200); begin con:='deptno=30'; return(con); end hide_sal_comm; 2）利用dmbs_rls.add_policy()添加一个安全策略 1234567 begin dbms_rls.add_policy(object_schema =&gt; 'scott', --指定schema object_name =&gt; 'emp', --指定表 policy_name =&gt; 'hide_sal_policy', --自定义此安全策略名称 policy_function =&gt; 'hide_sal_comm', --指定函数 sec_relevant_cols =&gt; 'sal,comm'); --指定过滤的字段end; 3）添加安全策略后访问该表，发现只能获得deptno=30的数据。这里要注意的是，只有当访问安全策略中指定字段时才起作用，如果select的字段中不包含这些字段，安全策略是不会起作用的 12select * from scott.emp; --起作用select ename,deptno from scott.emp; --不起作用，因为查询字段不包含sal或comm 4）上面定义的安全策略有个缺点，就是会把所有的字段都隐藏，如果你只想隐藏敏感字段，可以如下设置： 1234567891011--删除上面建的安全策略exec dbms_rls.drop_policy('scott','emp','hide_sal_policy');--Begindbms_rls.add_policy(object_schema =&gt; 'scott', object_name =&gt; 'emp', policy_name =&gt; 'hide_sal_policy', policy_function =&gt; 'hide_sal_comm', sec_relevant_cols =&gt; 'sal,comm', sec_relevant_cols_opt =&gt; dbms_rls.ALL_ROWS); end; 5）这时再执行同样的语句，可以发现返回所有行，只是敏感字段的数据被隐藏了 Vault和VPD,OLS不不一样的是，Vault在实际的生产环境下，最主要的目的是为了防止具有sys账户DBA滥用权限。在没有vault情况下，DBA可以随意查看数据，这对于一些企业（特别是金融领域）来说是不允许的，而有了Vault，就可以控制DBA不能访问应用的核心数据，如下图所示： 审计AuditOracle的审计是一个事后的工作，即数据库出现安全问题后，为了定位、发现问题的根源，可以通过审计追根溯源。Oracle审计主要包含以下3个部分： Trigger-based Auditing（触发器） Auditing the sys User-(SYS用户审计） Standard Auditing （标准审计）触发器审计下面是一个触发器审计的例子，一旦emp表的sal字段的值增大超过1.1倍，就在审计表emp_sal_audit里记录该次操作。 12345678910111213CREATE TRIGGER trg_a_idu_r_emp_sal AFTER INSERT OR DELETE OR UPDATE OF sal ON emp FOR EACH ROW BEGIN IF ( :NEW.sal &gt; :OLD.sal * 1.10 ) THEN INSERT INTO emp_sal_audit VALUES (:OLD.empno, :OLD.sal, :NEW.sal, USER, SYSDATE); END IF; END; SYS用户的审计对SYS用户的审计比较特殊，因为SYS用户的权限太大，它的审计信息不能存储在数据库里，否则SYS可以随意修改审计信息，因此sys用户审计日志写到操作系统日志中。下面是一个例子：1）首先启动对SYS用户的审计 1alter system set audit_sys_operations = true scope = spfile; 2）用SYS用户向测试表插入一条数据 1insert into test.t (object_id) values(1); 3）在操作系统日志中可以看到如下信息 1Audit trail: LENGTH : '176' ACTION :[7] 'CONNECT' DATABASE USER:[1] '/' PRIVILEGE :[6] 'SYSDBA' CLIENT USER:[12] 'CORP\xianzhu' CLIENT TERMINAL:[14] 'L-SHC-00436132' STATUS:[1] '0' DBID:[10] '1327298419' . 标准审计标准审计根据对象不同，可以分为以下4个部分： 审计会话 审计对象 审计操作 审计授权 1）首先，开启标准审计 1234--开启标准审计ALTER SYSTEM SET AUDIT_TRAIL = DB,EXTENDED SCOPE = SPFILE;--设置审计的表audit select, insert, update, delete on test.t; 2）在表上做DML操作，可以在审计表里查看相应审计信息 123456789col userid for a10col obj$name for a10col sqltext for a40select userid,obj$name,sqltext from sys.aud$ where userid='TEST' and obj$name='T'; USERID OBJ$NAME SQLTEXT---------- ---------- ----------------------------------------TEST T delete from test.tTEST T insert into t (object_id) values(1)]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[010-PLSQL]]></title>
    <url>%2FOracle%2F010-PLSQL%2F</url>
    <content type="text"><![CDATA[匿名块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253DECLARE l_Dummy_Nm NUMBER; l_Dummy_Str VARCHAR2(360); l_Exp_Err EXCEPTION; l_Rt_Status VARCHAR2(100); l_Rt_Message VARCHAR2(4000);BEGIN --1# 判断 IF 1 = 1 THEN NULL; ELSIF 1 &lt; 2 THEN RETURN; --结束程序 ELSE l_Rt_Status := 'E'; l_Rt_Message := '错误'; RAISE l_Exp_Err; --抛出自定义异常 END IF; --2# FOR循环 FOR Rec IN 1 .. 3 LOOP CONTINUE; EXIT; END LOOP; --3# WHILE循环 WHILE 1 &lt; 2 LOOP EXIT WHEN 1 = 1; END LOOP; --4# GOTO跳转 &lt;&lt;go_Flag&gt;&gt; GOTO Go_Flag; --#6 保存点 SAVEPOINT a; ROLLBACK TO a; --回滚保存点A之后产生的所有DML操作，原有参数和变量值不会产生影响 --7# 提交 COMMIT;EXCEPTION WHEN l_Exp_Err THEN ROLLBACK; Raise_Application_Error(-20002, '自定义异常:'); Dbms_Output.Put_Line('自定义异常:' || l_Rt_Status || l_Rt_Message); WHEN OTHERS THEN ROLLBACK; Dbms_Output.Put_Line(Substrb(REPLACE(Dbms_Utility.Format_Error_Backtrace || Dbms_Utility.Format_Error_Stack ,Chr(10) ,';') ,1 ,4000));END; 包NOCOPY应用于函数或存储过程在传递数据量很大的参数时，可起到优化性能的作用。当参数是OUT或者IN OUT类型时：没有NOCOPY＝按值传递；加上NOCOPY＝按引用传递。默认情况下，OUT模式的参数是以按值传递进行调用的，NOCOPY模式用于限定OUT模式在调用时按引用传递（它只是一个编译器暗示,不一定总是起作用）。传引用的方式会在赋值的时候立即生效 ，如果发生异常，也会返回你函数或存储过程中赋进入的值；如果是传值的方式，如果发生异常，等于函数或存储过程中赋进入的值都无效，返回的值还是原来参数传进去的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445CREATE OR REPLACE PACKAGE Test_Pkg IS --================================================== -- Test_Fun -- DESC:方法声明 --================================================== FUNCTION Test_Fun RETURN NUMBER; --================================================== -- Test_Proc -- DESC:存储过程声明 --================================================== PROCEDURE Test_Proc(x_Rt_Status OUT NOCOPY VARCHAR2 ,x_Rt_Message OUT NOCOPY VARCHAR2);END Test_Pkg;/CREATE OR REPLACE PACKAGE BODY Test_Pkg IS g_Pkg_Name CONSTANT VARCHAR2(100) := 'TEST_PKG'; --================================================== -- Test_Fun -- DESC:方法 --================================================== FUNCTION Test_Fun RETURN NUMBER IS l_Rt_Data NUMBER; BEGIN RETURN l_Rt_Data; END Test_Fun; --================================================== -- Test_Proc -- DESC:存储过程 --================================================== PROCEDURE Test_Proc(x_Rt_Status OUT NOCOPY VARCHAR2 ,x_Rt_Message OUT NOCOPY VARCHAR2) IS PRAGMA AUTONOMOUS_TRANSACTION; /*自治事务*/ l_Rt_Status VARCHAR2(10); l_Rt_Message VARCHAR2(4000); BEGIN l_Rt_Status := Apps.Fnd_Api.g_Ret_Sts_Success; l_Rt_Message := NULL; COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; x_Rt_Status := l_Rt_Status; x_Rt_Message := x_Rt_Message || l_Rt_Message; END Test_Proc;END Test_Pkg; 记录类型TIPS：索引从1开始 记录表提供的方法几种： COUNT：返回记录表中的数量 FIRST：返回记录表中最小索引值 LAST：返回记录表中最大的索引值 NEXT：返回记录表变量中的下一个索引 DELETE：删除记录表中的记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152DECLARE l_Empno Emp.Empno%TYPE; --表字段类型 l_Emp_Tb Emp%ROWTYPE; --单行记录表类型 TYPE Emp_Rec IS RECORD( --记录类型 Empno Emp.Empno%TYPE ,Ename Emp.Ename%TYPE ,Job Emp.Job%TYPE ,Mgr Emp.Mgr%TYPE ,Hiredate Emp.Hiredate%TYPE ,Sal Emp.Sal%TYPE ,Comm Emp.Comm%TYPE ,Deptno Emp.Deptno%TYPE); TYPE Emp_Rec_Tb IS TABLE OF Emp_Rec INDEX BY BINARY_INTEGER; --多行记录表类型 l_Emp_Rec_Tb Emp_Rec_Tb; --初始化 /*INDEX BY BINARY_INTEGER：下标数据类型，使得下标自增长，使用时不再需要初始化，也不需要每次extend一个空间 手动扩展空间eg: DECLARE TYPE Emp_Rec_Tb2 IS TABLE OF Emp_Rec; l_Emp_Rec_Tb2 Emp_Rec_Tb2 := Emp_Rec_Tb2(); BEGIN l_Emp_Rec_Tb2.Extend; l_Emp_Rec_Tb2(1).Empno := 2; l_Emp_Rec_Tb2.Extend; l_Emp_Rec_Tb2(2).Empno := 3; FOR i IN 1 .. l_Emp_Rec_Tb2.Count LOOP Dbms_Output.Put_Line(l_Emp_Rec_Tb2(i).Empno); END LOOP; END;*/BEGIN --#1.1 SELECT t.* INTO l_Emp_Tb FROM Emp t WHERE t.Empno = 7839; --#1.2 INSERT INTO Emp VALUES l_Emp_Tb; --#1.3 UPDATE Emp t SET t.Ename = l_Emp_Tb.Ename WHERE t.Empno = l_Emp_Tb.Empno; --#1.4 UPDATE Emp t SET t.Ename = l_Emp_Tb.Ename WHERE Row = l_Emp_Tb; --#2 SELECT t.* BULK COLLECT INTO l_Emp_Rec_Tb FROM Emp t; --BULK COLLECT可以将查询结果一次性地加载到collections FOR i IN 1 .. l_Emp_Rec_Tb.Count LOOP Dbms_Output.Put_Line('Empno=' || l_Emp_Rec_Tb(i).Empno || ',Ename=' || l_Emp_Rec_Tb(i) .Ename); END LOOP; Dbms_Output.Put_Line('Count1:' || l_Emp_Rec_Tb.Count); Dbms_Output.Put_Line('First:' || l_Emp_Rec_Tb.First); Dbms_Output.Put_Line('Last:' || l_Emp_Rec_Tb.Last); Dbms_Output.Put_Line('Next:' || l_Emp_Rec_Tb.Next(1)); l_Emp_Rec_Tb.Delete(l_Emp_Rec_Tb.Count); --只能从最后一个开始删除，不然会报错 l_Emp_Rec_Tb.Delete; --删除全部记录END; 游标 Emp_Cursor%FOUND 布尔型：当最近一次提取游标操作FETCH成功则为 TRUE,否则为FALSE Emp_Cursor%NOTFOUND 布尔型：与%FOUND相反 Emp_Cursor%ISOPEN 布尔型：当游标已打开时返回 TRUE Emp_Cursor%ROWCOUNT 数字型：返回已从游标中读取的记录数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556DECLARE CURSOR Emp_Cursor(p_Job VARCHAR2) IS SELECT t.Empno ,t.Ename FROM Emp t WHERE t.Job = p_Job FOR UPDATE NOWAIT; --对查询出来的数据添加行级锁，在打开游标时生效 l_Emp_Cursor Emp_Cursor%ROWTYPE; --同上相同类型的记录变量 l_Empno Emp.Empno%TYPE; l_Ename Emp.Ename%TYPE; TYPE Cursor_Type IS REF CURSOR; --游标变量 Temp_Cur Cursor_Type; l_Sql VARCHAR2(4000);BEGIN --1.1 显式打开关闭游标 OPEN Emp_Cursor('SALESMAN'); --打开游标 FETCH Emp_Cursor --提取游标 INTO l_Emp_Cursor; WHILE Emp_Cursor%FOUND LOOP --是否成功提取游标 Dbms_Output.Put_Line('1.1#' || l_Empno || ':' || l_Ename); FETCH Emp_Cursor INTO l_Empno ,l_Ename; END LOOP; CLOSE Emp_Cursor; --关闭游标 --2.1 隐式打开关闭游标 FOR Emp_Rec IN Emp_Cursor('SALESMAN') LOOP Dbms_Output.Put_Line('1.2#' || Emp_Rec.Empno || ':' || Emp_Rec.Ename); END LOOP; --2.2 隐式游标 FOR Emp_Rec IN (SELECT t.Empno ,t.Ename FROM Emp t WHERE t.Job = 'SALESMAN') LOOP Dbms_Output.Put_Line('2#' || Emp_Rec.Empno || ':' || Emp_Rec.Ename); END LOOP; --3 动态游标 l_Sql := 'SELECT t.Ename FROM Emp t WHERE t.Job = ' || p_Job; OPEN Temp_Cur FOR l_Sql; LOOP FETCH Temp_Cur INTO l_Ename; Dbms_Output.Put_Line(l_Ename); EXIT WHEN Temp_Cur%NOTFOUND; END LOOP; CLOSE Temp_Cur; --使用游标的属性判断DML是否执行了操作 UPDATE Emp SET sal=sal+100 WHERE empno=1234; IF SQL%FOUND THEN DBMS_OUTPUT.PUT_LINE('更新成功！'); END IF；END; 动态SQL绑定变量 12345678910DECLARE l_Sql VARCHAR2(240);BEGIN l_Sql := 'CREATE TABLE TABLENAME(ID NUMBER,NAME VARCHAR2(100))'; EXECUTE IMMEDIATE l_Sql; l_Sql := 'INSERT INTO TABLENAME VALUES (:1,:2)'; EXECUTE IMMEDIATE l_Sql USING 101, 'name'; --使用using绑定输入变量 COMMIT;END; 查询返回单行值 1234567891011121314DECLARE l_Sql VARCHAR2(240); l_Id NUMBER; l_Name VARCHAR2(100);BEGIN l_Sql := 'SELECT ID,NAME FROM TABLENAME WHERE ID=:1'; EXECUTE IMMEDIATE l_Sql INTO l_Id, l_Name USING '101'; Dbms_Output.Put_Line('ID=' || l_Id || ',NAME=' || l_Name);EXCEPTION WHEN OTHERS THEN Dbms_Output.Put_Line('Not data found!');END; 查询返回多行值 123456789101112131415161718DECLARE l_Sql VARCHAR2(240); TYPE Tablename_Rec IS RECORD( Id Tablename.Id%TYPE ,NAME Tablename.Name%TYPE); TYPE Tablename_Rec_Tb IS TABLE OF Tablename_Rec INDEX BY BINARY_INTEGER; l_Tablename_Rec_Tb Tablename_Rec_Tb;BEGIN l_Sql := 'SELECT ID,NAME FROM TABLENAME'; EXECUTE IMMEDIATE l_Sql BULK COLLECT INTO l_Tablename_Rec_Tb; FOR i IN 1 .. l_Tablename_Rec_Tb.Count LOOP Dbms_Output.Put_Line('ID=' || l_Tablename_Rec_Tb(i).Id || ',NAME=' ||l_Tablename_Rec_Tb(i).Name); END LOOP;EXCEPTION WHEN OTHERS THEN Dbms_Output.Put_Line('Not data found!' || SQLERRM);END; 动态调用存储过程 123456789DECLARE l_Sql VARCHAR2(240); l_Name VARCHAR2(20);BEGIN l_Sql := 'BEGIN TABLENAME_PKG(:1,:2); END;'; EXECUTE IMMEDIATE l_Sql USING '101', OUT l_Name; --输出变量需显式说明 Dbms_Output.Put_Line('NAME=' || l_Name);END;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[100-ODI]]></title>
    <url>%2FOracle%2F100-ODI%2F</url>
    <content type="text"><![CDATA[简介ODI（Oracle Date Integrator）是Oracle Fusion MiddleWare的一个组件，它可以实现不同以及相同异构数据源之间的数据同步与集成。ODI的架构中，主要有以下的对象：Repository 仓库、Studio 工作室、Agent 代理、Console 工作台1、Repository分为2种类型：Master和Work。Master库主要用于存储拓扑信息及对Work库的版本控制，用户权限控制等的管理。Work库是定义的各种用于ETL转换的对象，是实际的Project库。里面可以存储各种结构与对象。比如Project，Model，Interface，Workflow等等信息。可以基于Work库的这个特点，可以新建不同的Work，分别用于DEV，Exec等不同用途的库。达到以目的操作对应的库，方便设计权限等。尽可能独立存储，单独的Instance，或单独的Schema。2、Agent实际执行者的代理人角色。所要执行的SQL语句通过代理，首先连接到要执行的DB服务器，然后发送要执行的代码进行执行，并将结果发送到目标数据库。Agent接受多种执行方式：Studio，Console，命令行，Web Service，ODI Schedules环境说明： Win10(64位) ODI 11G JDK 1.8（64位） 安装安装前设置setup.exe兼容性win7和管理员权限，安装过程中无特殊说明默认设置即可安装过程中会出现会要求选择第二个安装盘路径 登陆配置创建主资料档案库先在ORACLE下拟先用orcl数据库用system用户，创建一个主资料档案库用户的数据库用户C##ODI_MASTER创建完进入ODI，新建-&gt;主资料档案库创建向导 创建主资料档案库-登录用户上一步已经把ODI的系统配置导入到C##ODI_MASTER，现在开始创建基于此用户的ODI登陆用户重复上一步，继续再创建一个开发工作使用的登陆用户 创建开发工作资料档案库在ORACLE下登陆system用户下创建工作资料档案库的用户C##ODI_WORK登陆ODI主资料档案库用户后，选择拓扑-&gt;资料档案库-&gt;新建工作资料档案库创建完成后重新登录ODI ，选择开发工作资料档案库用户，点击编辑信息，将工作资料档案库选上即可，确认后登陆即可 数据库对接配置创建数据库简略写下创建源数据库SOURCE和目标数据库TARGET用于测试 创建数据服务器拓扑-&gt;物理体系结构-&gt;Oracle 选中右键选择新建数据服务器建立SOURCE的数据服务器，保存时提示警告先忽略不管复上一步，再建立TARGET的数据服务器在刚建立的两个数据服务器上，分别右键新建两个物理方案 创建逻辑方案拓扑-&gt;逻辑体系结构-&gt;新建逻辑方案，选择刚建立的物理方案 创建模型模型用于将数据库表映射到ODI因为库中表较多，所以我们指定表进行逆向工程将SOURCE和TARGET的表分别通过逆向工程导入ODI我们需要建立三个相同表结构的表：SOURCE数据库：SOURCE_EMP，TARGET数据库：TARGET_EMP、TMP_TARGET_EMP因为没给TMP_TARGET_EMP表建立主键，我们所以需要在ODI设置关键字，不然会报错：如果未在目标数据存储中声明关键字, 则不能进行流控制 新建项目 导入知识模块定义：知识模块（KM）是代码模板，定义什么类型的SQL查询（插入，选择，等等）或是哪些脚本需要生成来完成数据提取，加载和转换操作。类型说明： RKM：RKM完成从源系统和目标系统的数据结构的反向工程来形成数据模型的功能。 CKM：CKM完成数据质量检查。 LKM：LKM完成从源数据库数据加载到临时表。 IKM：IKM完成从临时表的数据加载到目标表。 SKM：SKM完成ODI和WEB服务接口的功能。 SKM(Service KM)：Web服务知识模块，可以使用该知识模块来生成Web服务调用 创建过程因为在同一过程中处理SOURCE和TARGET不同数据源，所以这里勾选多连接，并选择数据库对应技术建立过程中的处理，下面建的三个处理都是使用上一步三个表的建表脚本可以先执行一遍，可以点击操作查看执行日志建立一个用于将TARGET的TMP表增量同步到正式表的过程 创建接口用于将SOURCE数据拉取到TARGET的TMP表我们建立的关键字在这里可以看到自动关联进来 新建程序包将过程和接口拖入图表区域连接起点击OdiSleep设置休眠时间这样就完成了不同数据库数据的定时增量同步功能了~ 调度生成场景后，新建调度任务设置重复间隔查看设置的调度设置调度后，并进入拓扑，打开对应的代理点击更新调度才能生效，点击查看调度可以查看到正在调度情况 FAQ1、错误：ORA-00904: “LASTUPDATE”: 标识符无效场景：接口同步报错，表中已经有LASTUPDATE字段，但是同步还是说标识符无效原因：下图可以看到用ODI同步的时候，不同的知识模块，会自己建立相应的临时表存放从源数据库拉取的数据，再同步到我们的表里。LASTUPDATE是后面加的，导致了ODI的临时表没有这个字段，从ODI的临时表导入我们表时，发现我们表多了LASTUPDATE字段，所以报错解决：删除ODI建立的临时表重新进行同步2、错误：ORA-01729: 需要数据库链接名场景：模型能映射表结构到ODI，但是接口同步报错解决：能映射表结构到ODI，说明数据服务器的JDBC连接到数据库端没问题，因为是不同数据库的同步，所以需要在红框中填入建好DBLINK，如果是本地同库不同schema可以直接用localhost3、参数传入一直为空场景：默认参数一直无法传入解决：先将执行日志界别跳高到6，查看日志中参数传入的值是什么，如果已经有默认值单传入还是空的，可以查看参数-&gt;历史记录，把删掉里面的记录 脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107--【主资料档案库】--创建档案库表空间CREATE TABLESPACE C##ODI_MASTER_TSLOGGING DATAFILE 'D:\Sortware\app\oracle\tablespace\apps\c##odi_master_ts.dbf'SIZE 32M AUTOEXTEND ON NEXT 32M MAXSIZE 10G EXTENT MANAGEMENT LOCAL;--创建用户CREATE USER C##ODI_MASTER IDENTIFIED BY "odi"DEFAULT TABLESPACE C##ODI_MASTER_TS;--授权GRANT DBA TO C##ODI_MASTER;--【开发工作资料档案库】--创建用户CREATE USER C##ODI_WORK IDENTIFIED BY "odi"DEFAULT TABLESPACE C##ODI_MASTER_TS;--授权GRANT CONNECT TO C##ODI_WORK;GRANT RESOURCE TO C##ODI_WORK;--TARGET到SOURCE的DBLINKCREATE DATABASE LINK SOURCE_DBL CONNECT TO SYSTEM IDENTIFIED BY 1234567 USING 'SOURCE';--【SOURCE数据库】--CREATE TABLE SOURCE_EMPCREATE TABLE SOURCE_EMP(empno NUMBER NOT NULL ,ename VARCHAR2(20) ,job VARCHAR2(50) ,mgr NUMBER ,hiredate DATE ,sal NUMBER ,comm NUMBER ,deptno NUMBER ,lastupdate DATE DEFAULT SYSDATE NOT NULL); --INSERT INIT DATAINSERT INTO Source_empVALUES (7369, 'SMITH', 'CLERK', 7902, To_Date('1980-12-17', 'YYYY-MM-DD'), 800.00, NULL, 20,SYSDATE);INSERT INTO Source_empVALUES (7499, 'ALLEN', 'SALESMAN', 7698, To_Date('1981-02-20', 'YYYY-MM-DD'), 1600.00, 300.00, 30,SYSDATE);INSERT INTO Source_empVALUES (7521, 'WARD', 'SALESMAN', 7698, To_Date('1981-02-22', 'YYYY-MM-DD'), 1250.00, 500.00, 30,SYSDATE);INSERT INTO Source_empVALUES (7566, 'JONES', 'MANAGER', 7839, To_Date('1981-04-02', 'YYYY-MM-DD'), 2975.00, NULL, 20,SYSDATE);INSERT INTO Source_empVALUES (7654, 'MARTIN', 'SALESMAN', 7698, To_Date('1981-09-28', 'YYYY-MM-DD'), 1250.00, 1400.00, 30,SYSDATE);INSERT INTO Source_empVALUES (7698, 'BLAKE', 'MANAGER', 7839, To_Date('1981-05-01', 'YYYY-MM-DD'), 2850.00, NULL, 30,SYSDATE);INSERT INTO Source_empVALUES (7782, 'CLARK', 'MANAGER', 7839, To_Date('1981-06-09', 'YYYY-MM-DD'), 2450.00, NULL, 10,SYSDATE); --【TARGET数据库】--CREATE TABLE TMP_TARGET_EMPCREATE TABLE TMP_TARGET_EMP(empno NUMBER NOT NULL ,ename VARCHAR2(20) ,job VARCHAR2(50) ,mgr NUMBER ,hiredate DATE ,sal NUMBER ,comm NUMBER ,deptno NUMBER ,lastupdate DATE DEFAULT SYSDATE NOT NULL);--CREATE TABLE TARGET_EMPCREATE TABLE TARGET_EMP(empno NUMBER NOT NULL ,ename VARCHAR2(20) ,job VARCHAR2(50) ,mgr NUMBER ,hiredate DATE ,sal NUMBER ,comm NUMBER ,deptno NUMBER ,lastupdate DATE DEFAULT SYSDATE NOT NULL);--【TEMP_TO_TARGET】--将从SOURCE同步到TARGET的TMP_TARGET_EMP表的数据，增量同步到TARGET_EMP表DECLARE l_Lastupdate DATE; l_Dummy_Nm NUMBER;BEGIN SELECT MAX(t.Lastupdate) INTO l_Lastupdate FROM Target_Emp t; FOR Rec IN (SELECT * FROM Tmp_Target_Emp s WHERE s.Lastupdate &gt; Nvl(l_Lastupdate, s.Lastupdate - 1)) LOOP SELECT COUNT(1) INTO l_Dummy_Nm FROM Target_Emp t WHERE t.Empno = Rec.Empno; IF l_Dummy_Nm = 0 THEN INSERT INTO Target_Emp t VALUES Rec; ELSE UPDATE Target_Emp t SET ROW = Rec WHERE t.Empno = Rec.Empno; END IF; END LOOP;EXCEPTION WHEN OTHERS THEN ROLLBACK;END;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[002-GIT]]></title>
    <url>%2FTools%2F002-GIT%2F</url>
    <content type="text"><![CDATA[版本控制简介集中式版本控制系统(SVN)版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病就是必须联网才能工作。 分布式版本控制系统(GIT)分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样工作的时候就不需要联网了。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑（GITHUB或GITLAB），但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 初始化本地仓库 版本库又称为仓库，英文名repository，可以简单理解成一个文件夹，这个文件夹里面的所有文件都被Git管理起来，每个文件的修改、删除都能跟踪，以便任何时刻都可以追踪或者在还原。 下载Git，安装完找到Git下Git Bash或右键选择Git Bash Here都可以打开Git命令窗口切换到要初始化为仓库的文件夹，执行命令 1git init 工作区：指初始化的目录版本库：初始化后工作区下有一个隐藏目录.git，就是Git的版本库。版本库中有暂存区（Index），还有Git自动创建的第一个主分支master，以及指向master的指针HEAD。 查看查看仓库状态 1git status 查看版本信息（即commit的记录） 123git log查看简要信息git log --pretty=oneline 查看版本差异 123456789101112比较工作区与暂存区git diff比较暂存区与最新本地版本库git diff --cached [&lt;path&gt;...] 比较工作区与最新本地版本库git diff HEAD [&lt;path&gt;...]比较工作区与指定commit-id的差异git diff commit-id [&lt;path&gt;...] 比较暂存区与指定commit-id的差异git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...] 比较两个commit-id之间的差异git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;] 文件操作添加文件没有任何显示说明成功，Unix的哲学是“没有消息就是好消息” 12345678提交单个文件git add TEST.txt提交所有变化git add -A 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)git add -u 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件git add . 删除文件 用git rm来删除文件，同时还会将这个删除操作记录下来； 用rm来删除文件，仅仅是删除了物理文件，没有将其从git的记录中剔除 12345678删除文件git rm test.filegit commit -m &quot;delete test.file&quot;或者rm test.filegit commit -am &quot;delete test.file&quot;切换到要删除文件的目录下，批量删除文件git rm * -r 提交文件 1git commit -m &apos;commit TEST&apos; 撤销修改正常GIT工作流程为3个步骤：(工作区) -&gt; add(提交暂存区) -&gt; commit(提交本地仓库) -&gt; push(提交远程仓库)对应产生5中状态：未修改(Origin) 、已修改(Modified) 、已暂存(Staged) 、已提交(Committed) 、已推送(Pushed) 已修改，未暂存checkout命令是把在工作区的修改撤销，有两种情况： 修改后还没有被放到暂存区，那就会回退到版本库 已经添加到暂存区后，那就会回退到暂存区 1234撤销单个文件修改git checkout -- TEST.txt撤销所有文件修改git checkout . 已暂存，未提交把最近一次提交的版本替换到暂存区 ，此操作不影响工作区 1git reset HEAD . 已提交，未推送(版本回退)在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本可以写成HEAD~100回退到上一版本（即：把当前分支最近一次提交版本覆盖到工作区，把暂存区的修改全部撤销）： 1git reset --hard HEAD^ Tips：回退后会看不到之前的版本号，可以用git reflog查看执行过的命令。如下查到回退前commit id为e4c3f5f，这样就可以用来回退到e4c3f5f 1234567git reflog5ac930c HEAD@&#123;0&#125;: reset: moving to HEAD^e4c3f5f HEAD@&#123;1&#125;: commit: commit 2 TEST#回退git reset --hard e4c3f5f Tips：Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本的时候，Git仅仅是把HEAD指针指向回退的版本 已推送因为本地仓库和远程仓库是等价的，所以只需要先恢复本地仓库，再强制push到远程仓库即可 12git reset --hard HEAD^git push -u origin master 分支管理每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。主分支即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 分支操作创建分支： 1git branch dev 切换分支： 1git checkout dev 查看分支： 1234查看分支名称git branch查看分支树状结构git log --graph --pretty=oneline --abbrev-commit 合并分支：用于合并指定分支到当前分支 1git merge dev 删除分支： 123456删除分支git branch -d dev一个没有被合并过的分支，如果要强行删除，需要使用大写的-D参数git branch -D test删除远程分支git branch origin :dev 简化分支线：把分叉的提交历史“整理”成一条直线，看上去更直观，缺点是本地的分叉提交会被修改 1git rebase 远程仓库通过SHH验证添加SSH KEY，不然无法推送数据到GITHUB先在本地生成SSH key： 1ssh-keygen -t rsa -C &quot;XXXXX@QQ.COM&quot; 用查看生成的KEY信息填写到GITHUB中 新建远程仓库 克隆远程仓库选择SSH验证，复制链接信息：打开Git Bash Here克隆远程仓库 1git clone git@github.com:TationGH/testRepo.git 新建分支输入新建分支名，回车，下面会出现创建分支的选项，点击即可创建分支后续就可以选择到新的分支了如果远程仓库建了dev分支，本地仓库未建此dev分支，可以将远程dev分支拉取到本地 1git checkout -b dev origin/dev 如果非上一步操作，而是本地和远程都单独建了dev分支，那就要先把两者先关联起来 1git branch --set-upstream-to=origin/dev dev 查看查看远程仓库库信息： 1git remote -v 推送推送当前分支到远程master分支 1git push origin master 拉取git fetch：拉取时不会把远程分支版本合并当前分支上，而是将远程分支版本放到一个隐藏的commit，可以通过diff对比两个版本的差异，这样操作更安全，一般执行流程如下 123456拉取分支git fetch origin dev对比差异git diff origin/dev合并分支git merge origin/dev git pull：相当于：git pull = git fetch + git merge少用git pull，用git fetch和git merge代替它 1git pull origin dev 解决冲突如果不同分支都对同一文件进行修改，合并有可能会提示冲突，大致输出错误信息如下： 123Auto-merging README.mdCONFLICT (content): Merge conflict in README.md #合并发生冲突Automatic merge failed; fix conflicts and then commit the result. 打开冲突文件可以看到git将冲突内容用符号分割，内容大致如下： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD11111=======22222&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支两个版本冲突的内容，我们修改保存其中一个版本后，就可以重新提交后合并 存储现场如果dev分支做了修改已add但不想commit，而此时需要用master开分支ISSUE-1修改BUG后提交，如果在ISSUE-1上修改会影响到工作区。可以把当前工作现场存储下来，工作区恢复到最后一次提交状态，等ISSUE提交完再恢复回来 1git stash 查看存储的工作现场： 1git stash list 恢复工作现场： 123456恢复最新的stash，stash内容并不删除，你需要用git stash drop来删除git stash apply恢复指定的stashgit stash apply stash@&#123;0&#125; 恢复的同时把stash内容也删除git stash pop 标签管理标签就是跟某个commit绑在一起有意义的名字，标签都只存储在本地，不会自动推送到远程给commit id（f52c633）打上标签，用-a指定标签名，-m指定说明文字 1git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 查看标签 1git show 删除标签： 1git tag -d v1 推送标签到远程仓库： 1234#推送某个标签到远程git push origin v1#一次性推送全部尚未推送到远程的本地标签git push origin --tags 删除远程仓库标签： 12git tag -d v1git push origin :refs/tags/v1 忽略文件使用文本编辑器创建一个.gitignore文件，提交到git，这样.gitignore文件里面写的文件名将被git忽略 123# gitignore file:test.txt*.exe]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[003-Lombok]]></title>
    <url>%2FTools%2F003-Lombok%2F</url>
    <content type="text"><![CDATA[简介Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁。 工作原理会发现在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。运行时解析：运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样就可以通过反射拿到该注解。java.lang,reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。编译时解析：编译时解析有两种机制，分别简单描述下：1）Annotation Processing Toolapt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因： api都在com.sun.mirror非标准包下 没有集成到javac中，需要额外运行 2）Pluggable Annotation Processing APIJSR 269自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下：Lombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下： javac对源代码进行分析，生成了一棵抽象语法树（AST） 运行过程中调用实现了“JSR 269 API”的Lombok程序 此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点 javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块） 优缺点优点： 能通过注解的形式自动生成构造器、getter/setter、equals等方法，提高了一定开发效率 让代码变得简洁，不用过多的去关注相应的方法 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺点： 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性 IDEA中的安装注意：IDEA上必须要支持Lombo插件，否则会报错打开IDEA的Setting –&gt; 选择Plugins选项 –&gt; 选择Browse repositories –&gt; 搜索lombok –&gt; 点击安装 –&gt; 安装完成重启IDEA –&gt; 安装成功在项目中添加Lombok依赖jar，在pom文件中添加如下部分。(不清楚版本可以在Maven仓库中搜索) 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Lombok有哪些注解 @Setter @Getter @Data @Log(泛型注解，具体有很多种形式) @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode @NonNull @Cleanup @ToString @RequiredArgsConstructor @Value @SneakyThrows @Synchronized @Log有如下可选择可用： 1234567891011121314//@CommonsLogprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);//@JBossLogprivate static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);//@Logprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());//@Log4jprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);//@Log4j2private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);//@Slf4jprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);//@XSlf4jprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 使用Lombok 12345678import lombok.extern.java.Log;import lombok.extern.slf4j.Slf4j;@Logpublic class LogExample &#123; public static void main(String... args) &#123; log.severe("Something's wrong here"); &#125;&#125; 不使用Lombok 123456public class LogExample &#123; private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName()); public static void main(String... args) &#123; log.severe("Something's wrong here"); &#125;&#125; 默认情况下，记录器的主题（或名称）将是使用注释进行@Log注释的类的类名称。这可以通过指定topic参数来定制。例如：@XSlf4j(topic=”reporting”)。该类型注解可以满足不同的日志系统的日志使用，Lombok提供了一些自定义配置项可以参看Log官方介绍 @Getter和@Setter该注解使用在类或者属性上，该注解可以使用在类上也可以使用在属性上。生成的getter遵循布尔属性的约定。例如：boolean类型的sex，getter方法为isSex而不是getSex在使用该注解时，会默认生成一个无参构造和对应的getter/setter方法该注解也可以使用在单个属性上，会默认生成一个无参构造 @NonNull该注解使用在属性上，该注解用于属性的非空检查，当放在setter方法的字段上，将生成一个空检查，如果为空，则抛出NullPointerException。 该注解会默认是生成一个无参构造。 @toString该注解使用在类上，该注解默认将所有非静态以名称-值的形式输出。 如果需要可以通过注释参数includeFieldNames来控制输出中是否包含的属性名称。 可以通过exclude参数中包含字段名称，可以从生成的方法中排除特定字段。 可以通过callSuper参数控制父类的输出。 includeFieldNames是否包含属性名称exclude 排除指定字段callSuper输出父类属性注意：父类也要有toString方法，不然打印的是对象内存地址 1234//父类无toString方法Person(super=com.motui.Person@abfe836, firstName=motui, address=北京, dateOfBirth=Tue Jan :: CST , sex=)//父类有toString方法Person(super=People(=), firstName=motui, address=北京, dateOfBirth=Tue Jan :: CST , sex=) @EqualsAndHashCode该注解使用在类上，该注解在类级别注释会同时生成equals和hashCode。存在继承关系需要设置callSuper参数为true。 @Data该注解使用在类上，该注解是最常用的注解，相当于@Getter、@Setter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode这5个注解的合集本质上使用@Data注解，类默认@ToString和@EqualsAndHashCode以及每个字段都有@Setter和@getter。该注解也会生成一个公共构造函数，可以将任何@NonNull和final字段作为参数。虽然@Data注解非常有用，但是它没有与其他注解相同的控制粒度。@Data提供了一个可以生成静态工厂的单一参数，将staticConstructor参数设置为所需要的名称，Lombok自动生成的构造函数设置为私有，并提供公开的给定名称的静态工厂方法。 @AllArgsConstructor该注解使用在类上，该注解提供一个全参数的构造方法，默认不提供无参构造。 @NoArgsConstructor该注解使用在类上，该注解提供一个无参构造 @RequiredArgsConstructor该注解使用在类上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。 @Value这个注解用在 类 上，会生成含所有参数的构造方法、get方法，此外还提供了equals、hashCode、toString 方法。注：没有setter @Cleanup该注解使用在属性前，该注解是用来保证分配的资源被释放。在本地变量上使用该注解，任何后续代码都将封装在try/finally中，确保当前作用于中的资源被释放。默认@Cleanup清理的方法为close，可以使用value指定不同的方法名称。 @Synchronized该注解使用在类或者实例方法上，Synchronized在一个方法上，使用关键字可能会导致结果和想要的结果不同，因为多线程情况下会出现异常情况。Synchronized 关键字将在this示例方法情况下锁定当前对象，或者class讲台方法的对象上多锁定。这可能会导致死锁现象。一般情况下建议锁定一个专门用于此目的的独立锁，而不是允许公共对象进行锁定。该注解也是为了达到该目的。 @SneakyThrows这个注解用在方法上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常。该注解需要谨慎使用。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[007-Maven]]></title>
    <url>%2FTools%2F007-Maven%2F</url>
    <content type="text"><![CDATA[简介Maven项目对象模型(POM、Project Object Model)，主要服务于基于Java平台的项目构建，依赖管理和项目信息管理。Maven的核心功能便是合理叙述项目间的依赖关系。 项目构建理想的项目构建是高度自动化，跨平台，可重用的组件，标准化的，使用maven就可以帮我们完成上述所说的项目构建过程。 依赖管理 假如正在开发项目A和B，A依赖于B中的某些类，那么如何维系这种依赖关系呢？未使用Maven前，一般将B打包为jar，并在A的Library下导入B的jar文件。手动控制项目依赖的缺点：如果修复了B中的bug，要么选择将B打包导入A中，要么将B发布出去并告知开发者使用方法。这样效率低下且存在人为失误。 依赖管理指使用Maven来管理项目中使用到的jar包，Maven管理的方式就是：自动下载项目所需要的jar包，统一管理jar包之间的依赖关系。 Maven安装安装Maven需安装好jdk 1.6+版本，并配置好JAVA环境变量Maven下载链接，安装完目录结果如下目录分析 bin：含有mvn运行的脚本 boot：含有plexus-classworlds类加载器框架 conf：含有settings.xml配置文件 lib：含有Maven运行时所需要的java类库 LICENSE.txt, NOTICE.txt, README.txt针对Maven版本，第三方软件等简要介绍 配置环境变量MAVEN_HOMEPath打开cmd窗口，输入mvn –v命令，能查看到Maven的相关信息，说明已经安装成功 IDEA创建Maven项目Tips：IDEA内置了maven GroupID：是项目组织唯一的标识符，是main目录里java的目录结构。按照约定规范举例：com即为项目域名后缀，假设公司为co，项目为webapp，groupId就为：com.co.webapp ArtifactID：是项目的唯一的标识符，实际对应项目的名称，也就是项目根目录的名称。 Version：指定了项目的当前版本，SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的版本。创建完项目，我们一般会手动在java包下根据GroupID建立对应路径 POM文件所有的Maven项目包含着一个名为pom.xml的文件，文件中记录着自身的等字段，这些字段在创建Maven项目时填写，Maven会依据它们来确定着项目唯一版本，另一个关键标签是，该标签下可以包含若干个标签，用来声明依赖关系。如：我们要添加JUNIT的jar包，可以到Maven远程中心仓库搜索JUNIT点击选择其中一个版本复制Maven框中的内容，把它们复制到pom的下： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.co.webapp&lt;/groupId&gt; &lt;artifactId&gt;webapp&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 点击同步后，就可以在Dependencies下看到下载到本地仓库的插件 POM常用标签maven下载依赖时，依次读取三个配置文件，分别是项目下的pom.xml 文件 、用户目录下的.m2/settings.xml 与 maven 全局配置settings.xml三者的级先是 pom.xml &gt; /home_dir/.m2/settings.xml &gt; /maven_dir/conf/settings.xml 。pom仅作用于本项目，用户setting作用于调用了此文件的项目，全局setting作用于所有项目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--project是根元素，通过其属性引入命名空间和schema文件--&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--parent元素用于引入父项目坐标--&gt; &lt;!--若本项目中没有显示规定某个元素的值，则使用父项目中的对应值--&gt; &lt;parent&gt; &lt;artifactId&gt;csb2-parent&lt;/artifactId&gt; &lt;groupId&gt;com.cvte.csb&lt;/groupId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;!--relativePath元素指定父项目pom.xml文件的相对路径--&gt; &lt;!--默认值是"../pom.xml",允许你指定一个不同的路径--&gt; &lt;!--Maven在构建当前项目时，首先从当前项目寻找父项目pom文件--&gt; &lt;!--如果不存在则relativePath路径下寻找--&gt; &lt;!--如果还不存在，则在本地仓库寻找--&gt; &lt;!--依然没找到的话，就在远程仓库寻找父项目pom文件--&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;!--POM版本号--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--本项目标识符和版本信息--&gt; &lt;groupId&gt;com.co.webapp&lt;/groupId&gt; &lt;artifactId&gt;webapp&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 声明构建时使用的编码，一般本地Maven编码为GBK，与项目UTF-8不符会报错 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!--本项目坐标三元组--&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目名称--&gt; &lt;name&gt;webapp&lt;/name&gt; &lt;!-- 项目的详细描述--&gt; &lt;description&gt;Maven test project&lt;/description&gt; &lt;!--dependencies元素用于指定项目相关依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖项的坐标三元组--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来 - compile ：默认范围，用于编译 - provided ：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime : 在执行时需要使用 - test : 用于test任务时使用 - system : 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--当计算传递依赖时，列出被排除的依赖构件集，主要用于解决版本冲突问题--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--dependencyManagement用于所依赖jar包进行版本管理的管理器--&gt; &lt;!--如果dependencies里没有声明version元素，就使用dependencyManagement里面对应的version元素，如果有就继承它，如果没有就会报错--&gt; &lt;!--如果dependencies中声明了version，优先以dependency里的version为准--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 插件 --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;!-- 依赖的驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 指定jar包上传的仓库 --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;Zts_repository&lt;/id&gt; &lt;name&gt;test repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/Zts_repository/&lt;/url&gt; &lt;/repository&gt; &lt;/distributionManagement&gt;&lt;/project&gt; 仓库概念仓库分为：本地仓库、第三方仓库(私服)、中央仓库 本地仓库：Maven会将工程中依赖的构件(Jar包)从远程下载到本机一个目录下，默认的仓库是在：$user.home/.m2/repository，如：C:\Users\ZTS.m2\repository 第三方仓库：又称为内部中心仓库，也称为私服，一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。私服可以使用的是局域网，所以一般公司都会创建这种第三方仓库，保证项目开发时，项目所需用的jar都从该仓库中拿，每个人的版本就都一样。 远程中心仓库：Maven内置了远程公用仓库：http://repo1.maven.org/maven2，这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。工程依赖的jar包如果本地仓库没有，默认从中央仓库下载 命令假设已经用IDEA创建了MAVEN项目，我们同时写了两个类用于测试，打开CMD命令行，进入项目根目录就可以执行Maven命令了 编译编译时会跟据POM文件声明的依赖，自动下载各种依赖的jar包，编译成功后根目录多了一个target文件夹，目录下多了.class文件 1mvn compile 清理删除编译项目时生成的target文件夹 1mvn clean 测试Maven先帮我们编译项目，然后再执行测试代码，生成了的target文件夹里面有classes和test-classes 1mvn test 打包打包成功之后，可以看到项目根目录下的target文件夹下生成了一个webapp-1.0-SNAPSHOT.jar 的jar包 1mvn package 安装安装实际对项目做了清理、编译、测试、打包，再把打包好的jar和相关的依赖声明放到本地仓库中 1mvn install Tips：Maven3不提供oracle JDBC driver，如果需要用到ojdbc，则需要自己下载jar。CMD命令行切换jar包所在目录，执行下面命令将jar安装到仓库 1mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0 -Dpackaging=jar -Dfile=ojdbc6-11.2.0.jar 部署&amp;调用详见008-Nexus]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[008-Nexus]]></title>
    <url>%2FTools%2F008-Nexus%2F</url>
    <content type="text"><![CDATA[私服是指私有服务器，是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构建。有了私服之后，当maven需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，在提供给本地仓库下载。 简介Nexus是一个强大的maven仓库管理器，它极大的简化了私服仓库的维护和外部仓库的访问。它不需要数据库而是使用文件系统加Lucene来组织数据，使用ExtJS来开发界面，利用Restlet来提供完整的REST APIs，通过IDEA和Eclipse集成使用，支持webDAV与LDAP安全身份认证。 优势 加速构建 稳定（应付一旦中央服务器出问题的情况） 控制和审计 能够建立内部公用仓库，统一开发规范 方便开发迭代和技术共享 安装Nexus 专业版是需要付费的，这里我们下载开源版Nexus OSS解压即可使用，安装包下有两个子目录： nexus-3.16.1-02：此目录是安装目录，该目录包含了Nexus 运行所需要的文件，如启动脚本、依赖jar包等 sonatype-work：此目录是工作目录，包含Nexus生成的配置、日志文件、仓库文件等。 操作命令执行命令前，需要先打开CMD进入nexus主目录下的bin目录，如：E:\nexus-3.16.1-02-win64\nexus-3.16.1-02\bin 12345678910注册服务nexus.exe /install nexus启动服务nexus.exe /start nexus停止服务nexus.exe /stop nexus重启服务nexus.exe /restart nexus卸载服务nexus.exe /uninstall nexus Tips：执行命令如果出现错误：java.lang.NumberFormatException: null，则可能是jdk版本不对，或路径中带中文在执行注册和启动命令后，可以打开任务管理器查看启动的服务： 访问启动服务后，大致等待几十秒服务完全启动就可以通过这个网址访问主页：http://localhost:8081/使用默认的用户名和密码登陆（admin/admin123）注：如果需要修改登录网址的端口号，可以到安装目录下E：\nexus-3.16.1-02-win64\sonatype-work\nexus3\etc打开nexus.properties文件，将application-port改成自己的端口，初始文件中代码都被#号注释了，只需将所有#删掉即可 Nexus仓库仓库类型： hosted：宿主仓库，主要用于部署无法从公共仓库获取的构件以及自己或第三方的项目构件 proxy：代理仓库，代理公共的远程仓库； group：仓库组，Nexus 通过仓库组统一管理多个仓库，这样我们在项目中直接请求仓库组即可请求到仓库组管理的多个仓库 总结：我们可以上传私有的项目到hosted，并配置proxy以获取第三方的依赖（比如可以配置中央仓库的地址）。前面两个都弄好了之后，在通过group聚合给客户提供统一的访问地址。 创建宿主仓库 创建代理仓库常用的远程仓库地址 1234http://repo1.maven.org/maven2/http://central.maven.org/maven2/http://repository.jboss.org/nexus/content/groups/public/http://maven.aliyun.com/nexus/content/groups/public/ 创建完需要检查状态是否有成功可以点进去重建下索引和清除缓存，本地maven项目在同步时，需要从索引检查jar包 创建仓库组 调用私服下载jar包将私服仓库组配置到settings.xml文件（配置在POM文件也可以） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;profiles&gt; &lt;profile&gt; &lt;!-- Zts_nexus为配置块名称，用户自己定义。可以复制多个repositories块用来配置不同仓库 --&gt; &lt;id&gt;Zts_nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Zts_group&lt;/id&gt; &lt;url&gt;http://localhost:8081/repository/Zts_group/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!-- 指定激活的配置块名称，必须激活才能生效配置 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;Zts_nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;!-- 如果要强制只在指定仓库下载jar包可以用mirrors标签，优先级大于上面的profiles --&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符，私服仓库名称 --&gt; &lt;id&gt;Zts_group&lt;/id&gt; &lt;!--此处配置所有的构建均从私有仓库中下载 *代表所有，也可以写central --&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;test repository&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL --&gt; &lt;url&gt;http://localhost:8081/repository/Zts_group/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 标签的id和url分别可以在Nexus界面查看到设置完setting文件后，假如我们在POM文件增加一个JUNIT依赖，点击同步后，Maven就从本地仓库查找JUNIT的jar包，找不到就查找私服，私服在宿主仓库（Zts_repository）找不到，继续往代理仓库（Zts_proxy）查找，代理仓库直接从远程仓库下载到代理仓库，再放到到本地。如图，我们可以看到jar被下载到代理仓库 上传jar包方式一：POM文件：指定项目部署路径 1234567&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;Zts_repository&lt;/id&gt; &lt;name&gt;test repository&lt;/name&gt; &lt;url&gt;http://localhost:8081/repository/Zts_repository/&lt;/url&gt; &lt;/repository&gt;&lt;/distributionManagement&gt; setting文件：增加上传需要通过Nexus用户验证 123456&lt;server&gt; &lt;!-- id为私服宿主仓库名称，与POM文件中对应 --&gt; &lt;id&gt;Zts_repository&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 打开CMD命令行进入到项目根文件目录中,执行命令 1mvn deploy 成功后可以在私服中可以看到部署的jar包方式二：手动指定部署的配置 1mvn deploy:deploy-file -DgroupId=com.co.webapp -DartifactId=webapp -Dversion=1.0 -Dpackaging=jar -Dfile=D:\GIT\webapp\target\webapp-1.0.jar -Durl=http://localhost:8081/repository/Zts_repository/ -DrepositoryId=Zts_repository 参数说明： -DgroupId：为上传的jar的groupId -DartifactId：为上传的jar的artifactId -Dversion：为上传的jar的version -Dpackaging：为文件类型，这里为jar -Dfile：为jar包路径，注：jar包推荐放在根目录，多层目录可能会报错 -Durl：为要上传的路径 -DrepositoryId 为repository的唯一标示]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AR]]></title>
    <url>%2FEBS%2FAR%2F</url>
    <content type="text"><![CDATA[事务处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980WITH Cust_Group_Tb AS (SELECT Hp.Party_Name ,Hca.Account_Number ,Hca.Cust_Account_Id ,Hcsu.Site_Use_Id ,Hcsu.Location ,Hl.Address1 Address FROM Ar.Hz_Parties Hp LEFT JOIN Ar.Hz_Cust_Accounts Hca ON Hca.Party_Id = Hp.Party_Id LEFT JOIN Ar.Hz_Cust_Acct_Sites_All Hcas ON Hcas.Cust_Account_Id = Hca.Cust_Account_Id LEFT JOIN Ar.Hz_Cust_Site_Uses_All Hcsu ON Hcsu.Cust_Acct_Site_Id = Hcas.Cust_Acct_Site_Id LEFT JOIN Ar.Hz_Party_Sites Hps ON Hps.Party_Site_Id = Hcas.Party_Site_Id LEFT JOIN Ar.Hz_Locations Hl ON Hl.Location_Id = Hps.Location_Id)SELECT Rcta.Customer_Trx_Id 事务处理id ,Rbsa.Name 来源 ,Rcta.Trx_Number 事务处理编号 ,Rctt.Name 类型 ,Rcta.Ct_Reference 参考 ,Xep.Name 法人主体 ,Rcta.Trx_Date 日期 ,Rctlga.Gl_Date Gl日期 ,Rcta.Invoice_Currency_Code 币种 ,Ship_Tb.Party_Name 收货方名称 ,Ship_Tb.Account_Number 收货方编号 ,Ship_Tb.Location 收货方地点 ,Ship_Tb.Address 收货方地址 ,Bill_Tb.Party_Name 收单方名称 ,Bill_Tb.Account_Number 收单方编号 ,Bill_Tb.Location 收单方地点 ,Bill_Tb.Address 收单方地址 ,Rctla.Line_Number 编号 ,Msi.Segment1 项目 ,Rctla.Description 摘要 ,Rctla.Uom_Code 单位 ,Rctla.Quantity_Invoiced 数量 ,Rctla.Unit_Selling_Price 未税单价 ,Rctla.Extended_Amount 未税金额 ,Rctla.Gross_Unit_Selling_Price 含税单价 ,Rctla.Gross_Extended_Amount 含税金额 ,Rctla.Tax_Classification_Code 税分类 ,Rctla_Tax.Tax_Rate 税率 ,Rctla.Sales_Order 销售订单 ,Rctla.Sales_Order_Line 销售订单行号 FROM Ar.Ra_Customer_Trx_All Rcta --AR事务处理头表 INNER JOIN Ar.Ra_Batch_Sources_All Rbsa --来源表 ON Rbsa.Batch_Source_Id = Rcta.Batch_Source_Id AND Rbsa.Org_Id = Rcta.Org_Id INNER JOIN Ar.Ra_Cust_Trx_Types_All Rctt --类型表 ON Rctt.Cust_Trx_Type_Id = Rcta.Cust_Trx_Type_Id INNER JOIN Xle.Xle_Entity_Profiles Xep ON Xep.Legal_Entity_Id = Rcta.Legal_Entity_Id INNER JOIN Ar.Ra_Cust_Trx_Line_Gl_Dist_All Rctlga --AR事务处理分配表 ON Rctlga.Account_Class = 'REC' AND Rctlga.Latest_Rec_Flag = 'Y' AND Rctlga.Customer_Trx_Id = Rcta.Customer_Trx_Id LEFT JOIN Cust_Group_Tb Ship_Tb --收货方 ON Ship_Tb.Cust_Account_Id = Rcta.Ship_To_Customer_Id AND Ship_Tb.Site_Use_Id = Rcta.Ship_To_Site_Use_Id LEFT JOIN Cust_Group_Tb Bill_Tb --收单方 ON Bill_Tb.Cust_Account_Id = Rcta.Bill_To_Customer_Id AND Bill_Tb.Site_Use_Id = Rcta.Bill_To_Site_Use_Id LEFT JOIN Ar.Ra_Customer_Trx_Lines_All Rctla --AR事务处理行 ON Rctla.Line_Type = 'LINE' AND Rctla.Customer_Trx_Id = Rcta.Customer_Trx_Id LEFT JOIN Ar.Ra_Customer_Trx_Lines_All Rctla_Tax --AR事务处理税 ON Rctla_Tax.Line_Type = 'TAX' AND Rctla_Tax.Link_To_Cust_Trx_Line_Id = Rctla.Customer_Trx_Line_Id LEFT JOIN Apps.Org_Organization_Definitions Ood ON Ood.Organization_Code &lt;&gt; 'MST' AND Ood.Operating_Unit = Rctla.Org_Id LEFT JOIN Inv.Mtl_System_Items_b Msi ON Msi.Inventory_Item_Id = Rctla.Inventory_Item_Id AND Msi.Organization_Id = Ood.Organization_Id WHERE 1 = 1 AND Rcta.Trx_Number = 'SY1805140274' 收款12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758WITH Cust_Tb AS (SELECT Hp.Party_Name ,Hca.Account_Number ,Hca.Cust_Account_Id ,Hcsu.Site_Use_Id ,Hcsu.Location FROM Ar.Hz_Parties Hp LEFT JOIN Ar.Hz_Cust_Accounts Hca ON Hca.Party_Id = Hp.Party_Id LEFT JOIN Ar.Hz_Cust_Acct_Sites_All Hcas ON Hcas.Cust_Account_Id = Hca.Cust_Account_Id LEFT JOIN Ar.Hz_Cust_Site_Uses_All Hcsu ON Hcsu.Cust_Acct_Site_Id = Hcas.Cust_Acct_Site_Id LEFT JOIN Ar.Hz_Party_Sites Hps ON Hps.Party_Site_Id = Hcas.Party_Site_Id)SELECT Acr.Cash_Receipt_Id 收款id ,Arm.Name 收款方法 ,Acr.Receipt_Number 收款编号 ,Acr.Amount 金额 ,Hou.Name 业务实体 ,Acr.Set_Of_Books_Id 账套id ,Acr.Legal_Entity_Id 法人id ,Acr.Currency_Code 币种 ,Decode(Acr.Type, 'CASH', '标准', 'MISC', '杂项') 类型 ,Flv.Meaning 状态 ,Acr.Receipt_Date 收款日期 ,Acrh.Gl_Date Gl日期 ,Acr.Comments 备注 ,Cb.Party_Name 名称 ,Cb.Account_Number 编号 ,Cb.Location 地点 ,Acr.Deposit_Date 存款日期 ,Cbb.Bank_Name 银行 ,Cbb.Bank_Branch_Name 分行 ,Cba.Bank_Account_Num 账户 FROM Ar.Ar_Cash_Receipts_All Acr INNER JOIN Apps.Hr_Operating_Units Hou ON Hou.Organization_Id = Acr.Org_Id INNER JOIN Apps.Ar_Receipt_Methods Arm ON Arm.Receipt_Method_Id = Acr.Receipt_Method_Id INNER JOIN Ar.Ar_Cash_Receipt_History_All Acrh ON Acrh.Cash_Receipt_Id = Acr.Cash_Receipt_Id AND Acrh.Org_Id = Acr.Org_Id AND Acrh.Current_Record_Flag = Nvl('Y', Acr.Receipt_Number) INNER JOIN Applsys.Fnd_Lookup_Values Flv ON Flv.Language = 'ZHS' AND Flv.Lookup_Type = 'RECEIPT_CREATION_STATUS' AND Flv.Lookup_Code = Acrh.Status LEFT JOIN Cust_Tb Cb ON Cb.Site_Use_Id = Acr.Customer_Site_Use_Id LEFT JOIN Ce.Ce_Bank_Acct_Uses_All Cbau ON Cbau.Bank_Acct_Use_Id = Acr.Remit_Bank_Acct_Use_Id AND Cbau.Org_Id = Acr.Org_Id LEFT JOIN Ce.Ce_Bank_Accounts Cba ON Cba.Bank_Account_Id = Cbau.Bank_Account_Id LEFT JOIN Apps.Ce_Bank_Branches_v Cbb ON Cbb.Branch_Party_Id = Cba.Bank_Branch_Id WHERE Acr.Receipt_Number = 'RX20181213005' 收款到子分类账123456789101112131415161718192021222324SELECT Xdl.Source_Distribution_Id_Num_1 ,Gcck.Concatenated_Segments ,Xah.* FROM Ar.Ar_Cash_Receipts_All Acra LEFT JOIN Ar.Ar_Cash_Receipt_History_All Acrha ON Acrha.Cash_Receipt_Id = Acra.Cash_Receipt_Id LEFT JOIN Ar.Ar_Distributions_All Ada ON Ada.Source_Id = Acrha.Cash_Receipt_History_Id AND Ada.Source_Table = 'CRH' LEFT JOIN Xla.Xla_Distribution_Links Xdl ON Xdl.Source_Distribution_Id_Num_1 = Ada.Line_Id AND Xdl.Source_Distribution_Type = 'AR_DISTRIBUTIONS_ALL' LEFT JOIN Xla.Xla_Ae_Lines Xal ON Xal.Ae_Header_Id = Xdl.Ae_Header_Id AND Xal.Ae_Line_Num = Xdl.Ae_Line_Num AND Xal.Application_Id = Xdl.Application_Id LEFT JOIN Apps.Gl_Code_Combinations Gcc ON Gcc.Code_Combination_Id = Xal.Code_Combination_Id LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcck ON Gcck.Code_Combination_Id = Gcc.Code_Combination_Id LEFT JOIN Xla.Xla_Ae_Headers Xah ON Xah.Ae_Header_Id = Xal.Ae_Header_Id AND Xah.Application_Id = Xal.Application_Id WHERE Acra.Receipt_Number = 'SY20190315002' 事务处理类型12345678910111213141516171819202122232425262728SELECT Rctt.Cust_Trx_Type_Id 事务处理类型id ,Rctt.Org_Id 业务实体id ,Rctt.Legal_Entity_Id 法人主体id ,Rctt.Name 名称 ,Rctt.Description 摘要 ,Decode(Rctt.Type, 'INV', '发票', 'DM', '借项通知单', 'CM', '贷项通知单') 分类 ,Decode(Rctt.Creation_Sign, 'P', '正好', 'N', '负号', 'A', '任何符号') 创建符号 ,Decode(Rctt.Default_Status, 'OP', '打开', 'CL', '关闭') 事务处理状态 ,Decode(Rctt.Default_Printing_Option, 'NOT', '不打印', 'PRI', '打印') 打印选项 ,Rctt.Start_Date 有效日期从 ,Rctt.End_Date 有效日期至 ,Rctt.Credit_Memo_Type_Id 贷项通知单类型id ,Rctt.Accounting_Affect_Flag 未结应收款 ,Rctt.Adj_Post_To_Gl 允许调整过账 ,Rctt.Post_To_Gl 过账至gl ,Rctt.Allow_Freight_Flag 允许调整过账 ,Rctt.Natural_Application_Only_Flag 仅限于自然核销 ,Rctt.Tax_Calculation_Flag 默认税分类 ,Rctt.Exclude_From_Late_Charges 从滞纳费用计算中排除 ,Rctt.Allow_Overapplication_Flag 允许超额核销 ,Gcck_Rec.Concatenated_Segments 应收账款账户 ,Gcck_Rev.Concatenated_Segments 收入账户 FROM Ar.Ra_Cust_Trx_Types_All Rctt LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcck_Rec ON Gcck_Rec.Code_Combination_Id = Rctt.Gl_Id_Rec LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcck_Rev ON Gcck_Rev.Code_Combination_Id = Rctt.Gl_Id_Rev WHERE 1 = 1 事务处理来源1234567891011SELECT Rbsa.Batch_Source_Id 来源ID ,Rbsa.Org_Id 业务实体id ,Rbsa.Legal_Entity_Id 法人主体id ,Rbsa.Name 名称 ,Rbsa.Description 摘要 ,Decode(Rbsa.Batch_Source_Type, 'INV', '人工', 'FOREIGN', '已导入') 类型 ,Decode(Rbsa.Status, 'A', 'Y', 'I', 'N') 有效 ,Rbsa.Start_Date 有效日期从 ,Rbsa.End_Date 有效日期至 FROM Ar.Ra_Batch_Sources_All Rbsa WHERE 1 = 1 应收款活动类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293SELECT Arta.Org_Id 业务实体id ,Arta.Receivables_Trx_Id 应收款活动类型id ,Arta.Name 应收款活动类型名称 ,Arta.Description 摘要 ,Arta.Type 类型 ,Decode(Arta.Status, 'A', 'Y', 'N') 状态 ,Gcck.Concatenated_Segments 会计科目 ,Gcc.Segment1 公司段 ,Gcc.Segment2 事业部段 ,Gcc.Segment3 部门段 ,Gcc.Segment4 会计科目段 ,Gcc.Segment5 产品段 ,Gcc.Segment6 公司间内部往来段 ,Gcc.Segment7 办事处段 ,Gcc.Segment8 保留段 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_COMPANY' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment1) 公司段名称 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_BU' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment2) 事业部段名称 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_DEPARTMENT' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Parent_Flex_Value_Low = Gcc.Segment2 AND Ffvv.Flex_Value = Gcc.Segment3) 部门段名称 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_ACCOUNT' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment4) 会计科目段 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_PRODUCT' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment5) 产品段名称 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_COMPANY' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment6) 公司间内部往来段 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_OFFICE' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment7) 办事处段名称 ,(SELECT Ffvt.Description FROM Apps.Fnd_Flex_Value_Sets Ffvs ,Apps.Fnd_Flex_Values Ffvv ,Apps.Fnd_Flex_Values_Tl Ffvt WHERE Ffvs.Flex_Value_Set_Id = Ffvv.Flex_Value_Set_Id AND Ffvs.Flex_Value_Set_Name = 'CVTE_COA_RESERVE2' AND Ffvv.Flex_Value_Id = Ffvt.Flex_Value_Id AND Ffvt.Language = 'ZHS' AND Ffvv.Flex_Value = Gcc.Segment8) 保留段名称 FROM Apps.Ar_Receivables_Trx_All Arta JOIN Apps.Gl_Code_Combinations Gcc ON Arta.Code_Combination_Id = Gcc.Code_Combination_Id LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcck ON Gcck.Code_Combination_Id = Gcc.Code_Combination_Id; 收款分类&amp;收款方法1234567891011121314151617181920212223242526272829303132333435SELECT Arc.Receipt_Class_Id 分类id ,Arc.Name 分类名称 ,Arm.Receipt_Method_Id 收款方法id ,Arm.Name 收款方法 ,Arm.Start_Date 起始日期 ,Arm.End_Date 结束日期 --汇款银行 ,Hou.Organization_Id 业务实体id ,Hou.Name 业务实体 ,Bank.Party_Name 银行 ,Branch.Party_Name 分行 ,Cba.Bank_Account_Name 银行账户 ,Cba.Bank_Account_Num 银行账号 ,Cba.Currency_Code 币种 ,Cba.Receipt_Multi_Currency_Flag 多币种 -- ,Cgac.Ap_Asset_Ccid 现金账户 --帐户控制 COA FROM Apps.Ar_Receipt_Classes Arc JOIN Apps.Ar_Receipt_Methods Arm ON Arm.Receipt_Class_Id = Arc.Receipt_Class_Id JOIN Apps.Ar_Receipt_Method_Accounts_All Arma ON Arma.Receipt_Method_Id = Arm.Receipt_Method_Id JOIN Apps.Hr_Operating_Units Hou ON Hou.Organization_Id = Arma.Org_Id JOIN Apps.Ce_Bank_Acct_Uses_All Cbau ON Cbau.Bank_Acct_Use_Id = Arma.Remit_Bank_Acct_Use_Id JOIN Apps.Ce_Bank_Accounts Cba ON Cba.Bank_Account_Id = Cbau.Bank_Account_Id JOIN Apps.Hz_Parties Branch ON Branch.Party_Id = Cba.Bank_Branch_Id LEFT JOIN Apps.Hz_Parties Bank ON Bank.Party_Id = Cba.Bank_Id LEFT JOIN Ce.Ce_Gl_Accounts_Ccid Cgac ON Cgac.Bank_Acct_Use_Id = Cbau.Bank_Acct_Use_Id WHERE 1 = 1; 客户基础信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107SELECT --组织 Hp.Party_Id 组织id ,Hp.Party_Number 注册标识 ,Hp.Orig_System_Reference 参考 ,Hp.Party_Name 组织名 ,Hp.Known_As 别名 ,Hp.Organization_Name_Phonetic 名称拼音 --账户 ,Hca.Cust_Account_Id 账号id ,Hca.Account_Number 帐号 ,Hca.Account_Name 账户说明 ,Flv_Class.Meaning 分类 ,Flv_Type.Meaning 帐户类型 ,Decode(Hca.Status, 'A', '有效', 'I', '失效', 'L', '全部', '') 账户状态 ,Hca.Attribute20 定金比例 ,Hca.Attribute10 发货附带确认书 ,Hca.Attribute19 增值税发票类型 ,Hca.Attribute1 可直接开立增值税发票 ,Hca.Attribute8 开户银行 ,Hca.Attribute9 银行帐号 ,Hca.Attribute2 产品事项 ,Hca.Attribute3 合同事项 ,Hca.Attribute4 下采购备注 ,Hca.Attribute5 下生产备注 ,Hca.Attribute6 出货事项 ,Hca.Attribute7 发票事项 ,Hca.Attribute11 是否按提前期采购 --账户地点 ,Hcas.Cust_Acct_Site_Id 账户地点id ,Decode(Hcas.Status, 'A', '有效', 'I', '失效', '') 地点状态 ,Hou.Name 业务实体 --地点 ,Hps.Party_Site_Id 地点id ,Hps.Party_Site_Number 地点编号 ,Hps.Party_Site_Name 地点名称 --地址 ,Hl.Location_Id 地址id ,Hl.Country 国家 ,Hl.Address1 地址行1 ,Hl.Address2 地址行2 ,Hl.Address3 地址行3 ,Hl.Address4 地址行4 --税配置文件 ,Zptp.Process_For_Applicability_Flag 允许税适用性 ,Decode(Zptp.Rounding_Level_Code, 'HEADER', '题头', 'LINE', '行', '') 舍入层 ,Decode(Zptp.Rounding_Rule_Code ,'UP' ,'进位' ,'DOWN' ,'舍去' ,'NEAREST' ,'四舍五入' ,'') 舍入规则 ,Zptp.Inclusive_Tax_Flag 将发票值设置为含税 ,Zptp.Country_Code 默认申报国家名称 ,Zptp.Rep_Registration_Number 默认申报登记编号 --业务目的 ,Hcsu.Site_Use_Id 业务目的id ,Hcsu.Primary_Flag 主要业务目的 ,Hcsu.Site_Use_Code 业务目的 ,Hcsu.Location 业务目的地点 ,Decode(Hcsu.Status, 'A', 'Active', 'I', 'Inactive', '') 业务目的状态 ,Hcsu.Bill_To_Site_Use_Id 关联收单方 ,Hcsu_Bill.Location 关联收单方 ,Gcc_Rec.Concatenated_Segments 应收款账户 ,Gcc_Rev.Concatenated_Segments 收入账户 ,Rtt.Name 付款条件 ,Hcsu.Tax_Reference 纳税登记号 ,Decode(Hcsu.Tax_Header_Level_Flag, 'Y', 'HEADER', 'N', 'LINE') 舍入层 ,Hcsu.Tax_Rounding_Rule 舍入规则 ,Hcsu.Tax_Code 税分类 ,Hcsu.Tax_Classification 地理位置类型分类 FROM Apps.Hz_Parties Hp --组织表 LEFT JOIN Apps.Hz_Cust_Accounts Hca --账户表 ON Hp.Party_Id = Hca.Party_Id LEFT JOIN Apps.Fnd_Lookup_Values Flv_Class --分类 ON Flv_Class.Lookup_Type = 'CUSTOMER CLASS' AND Flv_Class.Language = 'ZHS' AND Flv_Class.Lookup_Code = Hca.Customer_Class_Code LEFT JOIN Apps.Fnd_Lookup_Values Flv_Type --账户类型 ON Flv_Type.Lookup_Type = 'CUSTOMER_TYPE' AND Flv_Type.Language = 'ZHS' AND Flv_Type.Lookup_Code = Hca.Customer_Type LEFT JOIN Apps.Hz_Cust_Acct_Sites_All Hcas --账号地点关联表 ON Hcas.Cust_Account_Id = Hca.Cust_Account_Id LEFT JOIN Apps.Hr_Operating_Units Hou --业务实体表 ON Hou.Organization_Id = Hcas.Org_Id LEFT JOIN Apps.Hz_Party_Sites Hps --地点表 ON Hps.Party_Site_Id = Hcas.Party_Site_Id LEFT JOIN Apps.Hz_Locations Hl --地址表 ON Hl.Location_Id = Hps.Location_Id LEFT JOIN Apps.Zx_Party_Tax_Profile Zptp --税配置文件 ON Zptp.Party_Type_Code = 'THIRD_PARTY_SITE' AND Zptp.Party_Id = Hps.Party_Site_Id LEFT JOIN Apps.Hz_Cust_Site_Uses_All Hcsu --业务目的表 ON Hcsu.Cust_Acct_Site_Id = Hcas.Cust_Acct_Site_Id LEFT JOIN Apps.Hz_Cust_Site_Uses_All Hcsu_Bill --关联收单方表 ON Hcsu_Bill.Site_Use_Id = Hcsu.Bill_To_Site_Use_Id LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcc_Rec --应收款账户表 ON Gcc_Rec.Code_Combination_Id = Hcsu.Gl_Id_Rec LEFT JOIN Apps.Gl_Code_Combinations_Kfv Gcc_Rev --收入账户表 ON Gcc_Rev.Code_Combination_Id = Hcsu.Gl_Id_Rev LEFT JOIN Apps.Ra_Terms_Tl Rtt --付款条件表 ON Rtt.Language = 'ZHS' AND Hcsu.Payment_Term_Id = Rtt.Term_Id WHERE 1 = 1 AND Hp.Party_Number = 143253 --&amp; 组织层联系人12345678910111213141516171819202122232425262728SELECT Hp.Party_Name 组织名 ,Flv1.Meaning 用途 ,Ftv.Name 国家 ,Hcp.Contact_Point_Type 类型 ,Flv2.Meaning 联系方式 ,Hcp.Raw_Phone_Number 联系信息 ,Decode(Hcp.Status, 'A', '有效', 'I', '失效', '') 账户状态 ,Hcp.Primary_Flag 主要 FROM Apps.Hz_Parties Hp LEFT JOIN Apps.Hz_Contact_Points Hcp ON Hcp.Contact_Point_Type = 'PHONE' AND Hcp.Status = 'A' AND Hcp.Owner_Table_Name = 'HZ_PARTIES' AND Hcp.Owner_Table_Id = Hp.Party_Id LEFT JOIN Apps.Fnd_Timezones_Vl Ftv ON Ftv.Upgrade_Tz_Id = Hcp.Timezone_Id LEFT JOIN Apps.Fnd_Lookup_Values Flv1 ON Flv1.View_Application_Id = 222 AND Flv1.Language = 'ZHS' AND Flv1.Lookup_Type = 'CONTACT_POINT_PURPOSE' AND Flv1.Lookup_Code = Hcp.Contact_Point_Purpose LEFT JOIN Apps.Fnd_Lookup_Values Flv2 ON Flv2.View_Application_Id = 222 AND Flv2.Language = 'ZHS' AND Flv2.Lookup_Type = 'PHONE_LINE_TYPE' AND Flv2.Lookup_Code = Hcp.Phone_Line_TypeWHERE 1 = 1 AND Hp.Party_Number = 143253 --&amp; 账户层、地点层联系人12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364SELECT Hp.Party_Name 组织名 ,Hca.Account_Number 帐号 ,Hca.Account_Name 账户说明 ,Decode(Hca.Status, 'A', '有效', 'I', '失效', 'L', '全部', '') 账户状态 ,Decode(Hcar.Cust_Acct_Site_Id, NULL, 'ACCOUNT', 'SITE') 层次 ,Hcas.Cust_Acct_Site_Id 账户地点id ,Hou.Name 业务实体 ,Decode(Hcas.Status, 'A', '有效', 'I', '失效', '') 地点状态 ,Hoc.Job_Title 职称 ,Ftv.Territory_Short_Name 国家 ,Hpsub.Person_Pre_Name_Adjunct 称谓 ,Hpsub.Party_Name 联系人 ,Hoc.Contact_Number 联系人编号 ,Hcp_Mobile.Phone_Number 手机 ,Hcp_Gen.Phone_Number 电话 ,Hcp_Fax.Phone_Number 传真 ,Hcp_Email.Email_Address 邮箱 FROM Apps.Hz_Parties Hp LEFT JOIN Apps.Hz_Cust_Accounts Hca ON Hp.Party_Id = Hca.Party_Id LEFT JOIN Apps.Hz_Cust_Account_Roles Hcar ON Hcar.Role_Type = 'CONTACT' AND Hcar.Cust_Account_Id = Hca.Cust_Account_Id LEFT JOIN Apps.Hz_Cust_Acct_Sites_All Hcas ON Hcas.Cust_Acct_Site_Id = Hcar.Cust_Acct_Site_Id LEFT JOIN Apps.Hr_Operating_Units Hou ON Hou.Organization_Id = Hcas.Org_Id LEFT JOIN Apps.Hz_Relationships Hr ON Hr.Directional_Flag = 'F' AND Hr.Party_Id = Hcar.Party_Id LEFT JOIN Apps.Hz_Parties Hprel ON Hprel.Party_Id = Hr.Party_Id LEFT JOIN Apps.Hz_Parties Hpsub ON Hpsub.Party_Id = Hr.Subject_Id LEFT JOIN Apps.Hz_Org_Contacts Hoc ON Hr.Relationship_Id = Hoc.Party_Relationship_Id LEFT JOIN Apps.Fnd_Territories_Tl Ftv ON Hprel.Country = Ftv.Territory_Code AND Ftv.Language = 'ZHS' LEFT JOIN Apps.Hz_Contact_Points Hcp_Mobile ON Hcp_Mobile.Owner_Table_Name = 'HZ_PARTIES' AND Hcp_Mobile.Contact_Point_Type = 'PHONE' AND Hcp_Mobile.Phone_Line_Type = 'MOBILE' AND Hcp_Mobile.Status = 'A' AND Hcp_Mobile.Owner_Table_Id = Hcar.Party_Id LEFT JOIN Apps.Hz_Contact_Points Hcp_Gen ON Hcp_Gen.Owner_Table_Name = 'HZ_PARTIES' AND Hcp_Gen.Contact_Point_Type = 'PHONE' AND Hcp_Gen.Phone_Line_Type = 'GEN' AND Hcp_Gen.Status = 'A' AND Hcp_Gen.Owner_Table_Id = Hcar.Party_Id LEFT JOIN Apps.Hz_Contact_Points Hcp_Fax ON Hcp_Fax.Owner_Table_Name = 'HZ_PARTIES' AND Hcp_Fax.Contact_Point_Type = 'PHONE' AND Hcp_Fax.Phone_Line_Type = 'FAX' AND Hcp_Fax.Status = 'A' AND Hcp_Fax.Owner_Table_Id = Hcar.Party_Id LEFT JOIN Apps.Hz_Contact_Points Hcp_Email ON Hcp_Email.Owner_Table_Name = 'HZ_PARTIES' AND Hcp_Email.Contact_Point_Type = 'EMAIL' AND Hcp_Email.Status = 'A' AND Hcp_Email.Owner_Table_Id = Hcar.Party_Id WHERE 1 = 1 AND Hp.Party_Number = 143253 --&amp; 账户层联系人地点层联系人]]></content>
      <categories>
        <category>EBS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[010-Mybatis基础]]></title>
    <url>%2FTools%2F010-Mybatis%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[介绍MyBatis是一个支持普通SQL查询、存储过程、高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录。 快速入门使用到Maven+Mybatis+log4j+generator+lombok，最终实现的文件目录结构如下：pom文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.co.webapp&lt;/groupId&gt; &lt;artifactId&gt;webapp&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;!--generator配置文件生成路径--&gt; &lt;targetJavaProject&gt;$&#123;basedir&#125;/src/main/java&lt;/targetJavaProject&gt; &lt;targetMapperPackage&gt;com.co.webapp.mapper&lt;/targetMapperPackage&gt; &lt;targetModelPackage&gt;com.co.webapp.entity&lt;/targetModelPackage&gt; &lt;targetResourcesProject&gt;$&#123;basedir&#125;/src/main/resources&lt;/targetResourcesProject&gt; &lt;targetResourcesPackage&gt;mapper&lt;/targetResourcesPackage&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- mvn mybatis-generator:generate --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;!-- generate指定数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; db.properties：数据库配置文件 1234567891011#Mysql配置driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/testname=rootpassword=12345678#Oracle配置#driver=oracle.jdbc.driver.OracleDriver#url=jdbc:oracle:thin:@erptest-db.gz.cvte.cn:1531/erptest#name=#password= log4j.properties：log4j配置文件MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（优先级从高到低：SLF4J、Apache Commons Logging、Log4j 2、Log4j、JDK logging）。如果一个都未找到，日志功能就会被禁用。 12345log4j.rootLogger=DEBUG,Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppenderlog4j.appender.Console.layout=org.apache.log4j.PatternLayoutlog4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%nlog4j.logger.org.apache=INFO mybatis-config.xml：Mybatis配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 引用db.properties配置文件 --&gt; &lt;properties resource="db.properties"/&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;&lt;!--自动驼峰命名转换--&gt; &lt;setting name="logImpl" value="LOG4J"/&gt;&lt;!--指定使用LOG4J日志--&gt; &lt;/settings&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- value属性值引用db.properties配置文件中配置的值 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;name&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 注册mapper文件--&gt; &lt;mappers&gt; &lt;mapper resource="mapper/EMPMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; generatorConfig.xml：Generator配置文件Mybatis属于半自动ORM，在使用这个框架中，工作量最大的就是书写Mapping的映射文件，由于手动书写很容易出错，可以利用Mybatis-Generator来帮我们自动生成Dao、Model、Mapping相关文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 引用db.properties配置文件 --&gt; &lt;properties resource="db.properties"/&gt; &lt;!-- 数据库驱动，pom中加入插件时已经配置jdbc，此处无需配置--&gt; &lt;!-- &lt;classPathEntry location="D:\generator\mysql-connector-java-8.0.16.jar" /&gt; --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库配置 --&gt; &lt;jdbcConnection driverClass="$&#123;driver&#125;" connectionURL="$&#123;url&#125;" userId="$&#123;name&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;!-- true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型 false：默认, scale&gt;0;length&gt;18：使用BigDecimal; scale=0;length[10,18]：使用Long； scale=0;length[5,9]：使用Integer； scale=0;length&lt;5：使用Short；--&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 【entity】生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="$&#123;targetModelPackage&#125;" targetProject="$&#123;targetJavaProject&#125;"&gt; &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 【xml】生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="$&#123;targetResourcesPackage&#125;" targetProject="$&#123;targetResourcesProject&#125;"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 【接口】生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;targetMapperPackage&#125;" targetProject="$&#123;targetJavaProject&#125;"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- tableName（必要）：要生成对象的表名； 可选： 1，schema：数据库的schema； 2，catalog：数据库的catalog； 3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName 4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面； 5，enableInsert（默认true）：指定是否生成insert语句； 6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）； 7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句； 8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)； 9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）； 10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句； 11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）； 12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）； 13，modelType：参考context元素的defaultModelType，相当于覆盖； 14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性） 15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性 --&gt; &lt;table schema="test" tableName="EMP" domainObjectName="EMP" enableSelectByPrimaryKey="true" enableSelectByExample="false" enableInsert="false" enableUpdateByPrimaryKey="false" enableDeleteByPrimaryKey="false" enableDeleteByExample="false" enableCountByExample="false" enableUpdateByExample="false"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 配置完打开Maven，右键执行Generator执行完项目下自动生成了3个文件，省去了我们手写：下划线转驼峰的的EMP.java，数据库字段与实体字段映射关系的EMPMapper.xml，一个与EMPMapper.xml匹配的的接口EMPMapper.javaEMP.java：用于存储数据库返回的数据。删除其他不需要代码，使用lombok注解@Data 123456789101112package com.co.webapp.entity;@Datapublic class EMP &#123; private Integer empno; private String ename; private String job; private Integer mgr; private Date hiredate; private Float sal; private Float comm; private Integer deptno;&#125; EMPMapper.xml：定义执行的SQLnamespace为EMPMapper.java的路径+类名，id为对应的方法名，namespace和id都必须是全局唯一的，入参和出参类型必须与EMPMapper.java保持一致注：查询SQL语句结尾不能加分号，匿名块可以 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.co.webapp.mapper.EMPMapper"&gt; &lt;!-- Mybatis自动映射必须是数据库字段名与实体字段名完全一样， 如果两者不对应，则无法将结果集放入实体中，resultMap主要解决二者映射对应关系 --&gt; &lt;resultMap id="EMPMap" type="com.co.webapp.entity.EMP"&gt; &lt;result column="empno" jdbcType="INTEGER" property="empno"/&gt; &lt;result column="ename" jdbcType="VARCHAR" property="ename"/&gt; &lt;result column="job" jdbcType="VARCHAR" property="job"/&gt; &lt;result column="mgr" jdbcType="INTEGER" property="mgr"/&gt; &lt;result column="hiredate" jdbcType="DATE" property="hiredate"/&gt; &lt;result column="sal" jdbcType="REAL" property="sal"/&gt; &lt;result column="comm" jdbcType="REAL" property="comm"/&gt; &lt;result column="deptno" jdbcType="INTEGER" property="deptno"/&gt; &lt;/resultMap&gt; &lt;!-- statementType参数模式,parameterType参数类型，resultMap返回结果集类型 --&gt; &lt;select id="queryEMPEname" statementType="PREPARED" parameterType="String" resultMap="EMPMap"&gt; select * from EMP where ENAME = #&#123;ename,mode=IN,jdbcType=VARCHAR&#125; &lt;/select&gt; &lt;!-- 因配置文件已启用了自动驼峰命名转换，可以不需要resultMap也能自动实现对应 --&gt; &lt;!--&lt;select id="queryEMPEname" parameterType="String" resultType="com.co.webapp.entity.EMP"&gt; select * from EMP where ENAME = #&#123;ename,mode=IN,jdbcType=VARCHAR&#125; &lt;/select&gt;--&gt;&lt;/mapper&gt; EMPMapper.java：定义与数据库交互接口 123456789package com.co.webapp.mapper;public interface EMPMapper &#123; //方式一：xml public List&lt;EMP&gt; queryEMPEname(@Param("ename") String ename); //方式二：注解 @Select("select * from EMP where EMPNO = #&#123;empno,mode=IN,jdbcType=VARCHAR&#125;") public List&lt;EMP&gt; queryEMPEmpno(int empno);&#125; MybatisUtil.java：公用的Mybatis工具类，可以减少代码，配置公用 1234567891011121314151617181920212223242526272829303132package com.co.webapp.base;public class MybatisUtil &#123; /** * @Method getSqlSessionFactory * @Param [] * @Return org.apache.ibatis.session.SqlSessionFactory **/ public static SqlSessionFactory getSqlSessionFactory() &#123; String resource = "mybatis-config.xml"; //必须放在resources下，不然无法加载到 InputStream is = MybatisUtil.class.getClassLoader().getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); return factory; &#125; /** * @Method getSqlSession * @Param [] * @Return org.apache.ibatis.session.SqlSession **/ public static SqlSession getSqlSession() &#123; return getSqlSessionFactory().openSession(); &#125; /** * @Method getSqlSession * @Param [isAutoCommit]:true 自动提交事务,false 不自动提交事务 * @Return org.apache.ibatis.session.SqlSession **/ public static SqlSession getSqlSession(boolean isAutoCommit) &#123; return getSqlSessionFactory().openSession(isAutoCommit); &#125;&#125; Test.java：测试 1234567891011121314151617181920212223242526272829303132package com.co.webapp;public class Test &#123; @org.junit.Test public void EMPQueryTest() throws IOException &#123; //方式一：基于MybatisUtil+XML接口实现 //创建能执行映射文件中sql的sqlSession SqlSession sqlSession1 = MybatisUtil.getSqlSession(true);//参数：true，表示自动提交 //得到EMPMapper接口的实现类对象，EMPMapper接口的实现类对象由sqlSession.getMapper动态构建出来 EMPMapper mapper1 = sqlSession1.getMapper(EMPMapper.class); List&lt;EMP&gt; empList1 = mapper1.queryEMPEname("SMITH"); sqlSession1.close(); System.out.println("基于MybatisUtil+XML接口实现：" + empList1); //方式二：基于MybatisUtil+注解实现 SqlSession sqlSession2 = MybatisUtil.getSqlSession(true); EMPMapper mapper2 = sqlSession2.getMapper(EMPMapper.class); List&lt;EMP&gt; empList2 = mapper2.queryEMPEmpno(7499); sqlSession2.close(); System.out.println("基于MybatisUtil+注解接口实现：" + empList2); //方式三：基于加载器+XML实现 String resource = "mybatis-config.xml"; //使用MyBatis提供的Resources类加载mybatis的配置文件 Reader reader = Resources.getResourceAsReader(resource); SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession3 = sessionFactory.openSession(true); String statement = "com.co.webapp.mapper.EMPMapper.queryEMPEname";//namespace+id List&lt;EMP&gt; empList3 = sqlSession3.selectList(statement, "WARD"); sqlSession3.close(); System.out.println("基于加载器+XML实现:" + empList3); &#125;&#125; 执行结果： 参数以#{userId，mode=IN，jdbcType=INTEGER}举例： mode：声明参数方式（IN、OUT、INOUT） jdbcType：声明入参类型 如果接口入参写了@Param(“userId”)或入参类型为Map、实体等，则可用对应的key做别名 如果没写，则可用 #{0} 、 #{1}这样默认顺序声明参数 参数中#{}和${}区别： #{}：Mybatis拼装sql时会自动对参数添加单引号’’ ，如传入的参数为123，会变成’123’ ${}：Mybatis不对参数做任何转换，一般用于传入表名或字段名使用，可能导致SQL注入，使用$需要同时指定属性statementType=”STATEMENT”，开启非预编译模式。 标签select、insert、update、delete parameterType：参数类型，如：实体(com.co.webapp.entity.EMP)、int resultType ：返回类型，如：实体(com.co.webapp.entity.EMP)、Map、List resultMap：返回类型，如果查询出来的列名和实体属性名不一致，可以定义resultMap对数据库字段名和实体属性名指定映射关系。注：resultType 与resultMap 不能并用 12345678&lt;mapper namespace="com.co.webapp.mapper.EMPMapper"&gt; &lt;resultMap id="EMPMap" type="com.co.webapp.entity.EMP"&gt; &lt;result column="empno" jdbcType="INTEGER" property="empno"/&gt; &lt;/resultMap&gt; &lt;select id="queryEMP" statementType="PREPARED" parameterType="String" resultMap="EMPMap"&gt; select * from EMP where ENAME = #&#123;0&#125; &lt;/select&gt;&lt;/mapper&gt; if通常用于WHERE语句中，通过判断参数值来决定是否使用某个查询条件 1234567&lt;update id="updateEMP" parameterType="com.co.webapp.entity.EMP"&gt; UPDATE EMP SET ENAME = #&#123;ename,mode=IN,jdbcType=VARCHAR&#125; WHERE 1 = 1 &lt;if test="empno != null and empno != ''"&gt; AND EMPNO = #&#123;empno,mode=IN,jdbcType=VARCHAR&#125; &lt;/if&gt;&lt;/update&gt; foreach主要用于构建in条件，实现在sql中对集合进行迭代，注：如果collection参数为空就无法完成拼接SQL会报错，可以用if来先做是否为空的判断主要属性： collection：类型可以为list、array数组、map item：表示集合中每一个元素进行迭代时的别名 index：指代每次迭代坐标位置 open：表示语句以什么开始 separator：表示在每次进行迭代之间以什么符号作为分隔符 close：表示语句以什么结束 批量查询 12345678910//接口public List&lt;EMP&gt; queryEMP(@Param("empnoList") List&lt;Integer&gt; empnoList);//XML&lt;select id="queryEMP" parameterType="String" resultType="com.co.webapp.entity.EMP"&gt; SELECT * FROM EMP WHERE EMPNO IN &lt;!-- collection：上面@Param()指定了入参名字，item：给collection值起的别名 --&gt; &lt;foreach collection="empnoList" index="index" item="empno" open="(" separator="," close=")"&gt; #&#123;empno,mode=IN,jdbcType=VARCHAR&#125; &lt;/foreach&gt;&lt;/select&gt; 批量插入 123456789101112//接口public void insertEMP(@Param("empList") List&lt;EMP&gt; empList);//XML&lt;insert id="insertEMP" parameterType="java.util.List"&gt; BEGIN &lt;foreach collection="empList" index="index" item="emp" separator=";" open="" close=""&gt; INSERT INTO EMP(EMPNO, ENAME) VALUES (#&#123;emp.empno,mode=IN,jdbcType=INTEGER&#125;,#&#123;emp.ename,mode=IN,jdbcType=VARCHAR&#125;) &lt;/foreach&gt; ;END;&lt;/insert&gt; choose按顺序判断when中的条件是否成立，如果有一个成立则结束。当choose中所有when的条件都不满则时，则执行 otherwise 123456789101112131415//接口//如果对于入参是集合类型，且参数写了@Param("empMap")，则XML中入参需要加前缀，如:empMap.userIdpublic List&lt;EMP&gt; queryEMP(Map empMap); //XML&lt;select id="queryEMP" parameterType="java.util.Map" resultType="com.co.webapp.entity.EMP"&gt; SELECT * FROM EMP WHERE 1=1 &lt;choose&gt; &lt;when test="empno != null and empno != '' "&gt; AND EMPNO = #&#123;empno,mode=IN,jdbcType=VARCHAR&#125; &lt;/when&gt; &lt;otherwise&gt; AND ENAME = #&#123;ename,mode=IN,jdbcType=VARCHAR&#125; &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where如果where的标签中有返回值的话，就插入一个”where” 12345678&lt;select id="queryEMP" parameterType="java.util.Map" resultType="com.co.webapp.entity.EMP"&gt; SELECT * FROM EMP &lt;where&gt; &lt;if test="empno == -1"&gt; AND 1 = 1 &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; set当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以自动添加SET 关键字，并且自动剔除追加到条件末尾的不需要用到的逗号 123456789&lt;update id="updateEMP" parameterType="com.co.webapp.entity.EMP"&gt; UPDATE EMP &lt;set&gt; &lt;if test="ename != null and ename != ''"&gt; ENAME = #&#123;ename,mode=IN,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; WHERE EMPNO = #&#123;empno,mode=IN,jdbcType=INTEGER&#125;&lt;/update&gt; association、collection两者适用场景：调用一次查询，将表A和表B关联查询出的结果集，分别放入实体A和实体B，允许二层及以上的嵌套查询association：关联，一对一和多对一查询 12345678910111213141516171819202122232425262728//EMPInteger empno;String ename;Integer deptno;DEPT deptEntity;//DEPTInteger deptno;String dname;String loc;&lt;resultMap id="EMP" type="com.co.webapp.entity.EMP"&gt; &lt;id column="EMPNO" property="empno" jdbcType="INTEGER"/&gt; &lt;result column="ENAME" property="ename" jdbcType="VARCHAR"/&gt; &lt;result column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;association property="deptEntity" javaType="com.co.webapp.entity.DEPT"&gt; &lt;id column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;result column="DNAME" property="dname" jdbcType="VARCHAR"/&gt; &lt;result column="LOC" property="loc" jdbcType="VARCHAR"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="queryEMP" resultMap="EMP"&gt;SELECT * FROM Emp e ,Dept d WHERE e.DEPTNO = d.DEPTNO&lt;/select&gt; collection：聚集，一对多查询 12345678910111213141516171819202122232425262728//EMPInteger empno;String ename;Integer deptno;List&lt;DEPT&gt; deptEntityList;//DEPTInteger deptno;String dname;String loc;&lt;resultMap id="EMP" type="com.co.webapp.entity.EMP"&gt; &lt;id column="EMPNO" property="empno" jdbcType="INTEGER"/&gt; &lt;result column="ENAME" property="ename" jdbcType="VARCHAR"/&gt; &lt;result column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;collection property="deptEntityList" ofType="com.co.webapp.entity.DEPT"&gt; &lt;id column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;result column="DNAME" property="dname" jdbcType="VARCHAR"/&gt; &lt;result column="LOC" property="loc" jdbcType="VARCHAR"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="queryEMP" resultMap="EMP"&gt;SELECT * FROM Emp e ,Dept d WHERE e.DEPTNO = d.DEPTNO&lt;/select&gt; 额外：这种方式用association或collection都可以，这种方式相当于两次查询，性能和效率较低 1234567891011121314151617181920212223242526272829//EMPInteger empno;String ename;Integer deptno;List&lt;DEPT&gt; deptEntityList;//DEPTInteger deptno;String dname;String loc;&lt;resultMap id="EMP" type="com.co.webapp.entity.EMP"&gt; &lt;id column="EMPNO" property="empno" jdbcType="INTEGER"/&gt; &lt;result column="ENAME" property="ename" jdbcType="VARCHAR"/&gt; &lt;result column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;!--column声明两个表是通过什么字段关联上的--&gt; &lt;association column="DEPTNO" property="deptEntityList" select="queryDEPT"/&gt;&lt;/resultMap&gt;&lt;select id="queryEMP" resultMap="EMP"&gt;SELECT * FROM Emp e&lt;/select&gt;&lt;resultMap id="DEPT" type="com.co.webapp.entity.DEPT"&gt; &lt;id column="DEPTNO" property="deptno" jdbcType="INTEGER"/&gt; &lt;result column="DNAME" property="dname" jdbcType="VARCHAR"/&gt; &lt;result column="LOC" property="loc" jdbcType="VARCHAR"/&gt;&lt;/resultMap&gt;&lt;select id="queryDEPT" parameterType="int" resultMap="DEPT"&gt;SELECT * FROM Dept d WHERE DEPTNO = #&#123;deptno&#125;&lt;/select&gt; 调用存储过程传入类型为Map，返回参数reCode和rtMessage会自动封装到map里面 12345678910//接口public void callTest(Map empMap);//XML&lt;select id="callTest" statementType="CALLABLE" parameterType="java.util.Map"&gt; BEGIN Apps.Test.Emp(x_Rt_Status =&gt; #&#123;rtCode,mode=OUT,jdbcType=VARCHAR&#125; ,x_Rt_Message =&gt; #&#123;rtMessage,mode=OUT,jdbcType=VARCHAR&#125; ,p_User_Id =&gt; #&#123;userId,mode=IN,jdbcType=VARCHAR&#125;); END;&lt;/select&gt; 参数模式STATEMENT（非预编译）、PREPARED（预编译）、CALLABLE。默认使用：PREPARED。区别： STATEMENT: 普通的不带参的查询SQL，支持批量更新，批量删除 PREPARED: 可变参数的SQL，编译一次多次执行，效率高，安全性好，有效防止Sql注入等问题，支持批量更新，批量删除 CALLABLE: 继承自PREPARED，支持带参数的SQL操作，支持调用存储过程，提供了对输入参数(IN)/输出参数(OUT)的支持，注：调用存储过程需用此方式]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
</search>
